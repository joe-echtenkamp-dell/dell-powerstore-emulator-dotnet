/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Com.Dell.Emulator.Powerstore.Models
{ 
    /// <summary>
    /// Parameters for the network create operation. Was added in version 2.0.0.0.
    /// </summary>
    [DataContract]
    public partial class NetworkCreate : IEquatable<NetworkCreate>
    { 
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [Required]
        
        [DataMember(Name="type")]
        public NetworkTypeEnum? Type { get; set; }

        /// <summary>
        /// Name of the network.
        /// </summary>
        /// <value>Name of the network.</value>
        [Required]
        
        [StringLength(128, MinimumLength=1)]
        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// Gets or Sets IpVersion
        /// </summary>
        [Required]
        
        [DataMember(Name="ip_version")]
        public IpVersionTypeEnum? IpVersion { get; set; }

        /// <summary>
        /// * Purposes of the network. * This returns a list of purposes for the networks that support multiple purposes per network, like storage network. * Returns an empty list for the single purposed networks, like management, vMotion, ICD and ICM. 
        /// </summary>
        /// <value>* Purposes of the network. * This returns a list of purposes for the networks that support multiple purposes per network, like storage network. * Returns an empty list for the single purposed networks, like management, vMotion, ICD and ICM. </value>
        [Required]
        
        [DataMember(Name="purposes")]
        public List<NetworkPurposeEnum> Purposes { get; set; }

        /// <summary>
        /// VLAN identifier.
        /// </summary>
        /// <value>VLAN identifier.</value>

        [Range(0, 4094)]
        [DataMember(Name="vlan_id")]
        public int? VlanId { get; set; }

        /// <summary>
        /// * Network gateway in IPv4 or IPv6 format, corresponding to the network&#39;s IP version. * Specify empty string to remove the gateway. 
        /// </summary>
        /// <value>* Network gateway in IPv4 or IPv6 format, corresponding to the network&#39;s IP version. * Specify empty string to remove the gateway. </value>

        [DataMember(Name="gateway")]
        public string Gateway { get; set; }

        /// <summary>
        /// Network prefix length. (Used for both IPv4 and IPv6).
        /// </summary>
        /// <value>Network prefix length. (Used for both IPv4 and IPv6).</value>
        [Required]
        
        [Range(1, 127)]
        [DataMember(Name="prefix_length")]
        public int? PrefixLength { get; set; }

        /// <summary>
        /// * New storage discovery IP address in IPv4 or IPv6 format, corresponding to the network&#39;s IP version. * This can only be specified when creating the storage network. * Specify empty string to omit the storage discovery IP address. 
        /// </summary>
        /// <value>* New storage discovery IP address in IPv4 or IPv6 format, corresponding to the network&#39;s IP version. * This can only be specified when creating the storage network. * Specify empty string to omit the storage discovery IP address. </value>

        [DataMember(Name="storage_discovery_address")]
        public string StorageDiscoveryAddress { get; set; }

        /// <summary>
        /// * Cluster management IP address in IPv4 or IPv6 format, corresponding to the network&#39;s IP version. * This can only be specified when creating these network types - * - File_Mobility - floating IP address for file mobility network.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>* Cluster management IP address in IPv4 or IPv6 format, corresponding to the network&#39;s IP version. * This can only be specified when creating these network types - * - File_Mobility - floating IP address for file mobility network.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="cluster_mgmt_address")]
        public string ClusterMgmtAddress { get; set; }

        /// <summary>
        /// Maximum Transmission Unit (MTU) packet size set on network interfaces, in bytes.
        /// </summary>
        /// <value>Maximum Transmission Unit (MTU) packet size set on network interfaces, in bytes.</value>
        [Required]
        
        [Range(1280, 9000)]
        [DataMember(Name="mtu")]
        public int? Mtu { get; set; }

        /// <summary>
        /// IP addresses to add in IPv4 or IPv6 format.
        /// </summary>
        /// <value>IP addresses to add in IPv4 or IPv6 format.</value>

        [DataMember(Name="add_addresses")]
        public List<string> AddAddresses { get; set; }

        /// <summary>
        ///  Was added in version 3.0.0.0.
        /// </summary>
        /// <value> Was added in version 3.0.0.0.</value>

        [DataMember(Name="nvme_discovery_mode")]
        public NVMeDiscoveryModeEnum? NvmeDiscoveryMode { get; set; }

        /// <summary>
        /// IP address of the NVMe Centralized Discovery Controller (CDC). This is only applicable if network contains NVMe_TCP among its purposes, and nvme_discovery_mode is set to Manual_CDC.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>IP address of the NVMe Centralized Discovery Controller (CDC). This is only applicable if network contains NVMe_TCP among its purposes, and nvme_discovery_mode is set to Manual_CDC.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="nvme_cdc_address")]
        public string NvmeCdcAddress { get; set; }

        /// <summary>
        /// TCP port of the NVMe Centralized Discovery Controller (CDC). This is only applicable if network contains NVMe_TCP among its purposes, and nvme_discovery_mode is set to Manual_CDC. The valid values: 8009 or from 49152 to 49999 or 50100 to 65535.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>TCP port of the NVMe Centralized Discovery Controller (CDC). This is only applicable if network contains NVMe_TCP among its purposes, and nvme_discovery_mode is set to Manual_CDC. The valid values: 8009 or from 49152 to 49999 or 50100 to 65535.  Was added in version 3.0.0.0.</value>

        [Range(8009, 65535)]
        [DataMember(Name="nvme_cdc_port")]
        public int? NvmeCdcPort { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NetworkCreate {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  IpVersion: ").Append(IpVersion).Append("\n");
            sb.Append("  Purposes: ").Append(Purposes).Append("\n");
            sb.Append("  VlanId: ").Append(VlanId).Append("\n");
            sb.Append("  Gateway: ").Append(Gateway).Append("\n");
            sb.Append("  PrefixLength: ").Append(PrefixLength).Append("\n");
            sb.Append("  StorageDiscoveryAddress: ").Append(StorageDiscoveryAddress).Append("\n");
            sb.Append("  ClusterMgmtAddress: ").Append(ClusterMgmtAddress).Append("\n");
            sb.Append("  Mtu: ").Append(Mtu).Append("\n");
            sb.Append("  AddAddresses: ").Append(AddAddresses).Append("\n");
            sb.Append("  NvmeDiscoveryMode: ").Append(NvmeDiscoveryMode).Append("\n");
            sb.Append("  NvmeCdcAddress: ").Append(NvmeCdcAddress).Append("\n");
            sb.Append("  NvmeCdcPort: ").Append(NvmeCdcPort).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((NetworkCreate)obj);
        }

        /// <summary>
        /// Returns true if NetworkCreate instances are equal
        /// </summary>
        /// <param name="other">Instance of NetworkCreate to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NetworkCreate other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Type == other.Type ||
                    Type != null &&
                    Type.Equals(other.Type)
                ) && 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    IpVersion == other.IpVersion ||
                    IpVersion != null &&
                    IpVersion.Equals(other.IpVersion)
                ) && 
                (
                    Purposes == other.Purposes ||
                    Purposes != null &&
                    Purposes.SequenceEqual(other.Purposes)
                ) && 
                (
                    VlanId == other.VlanId ||
                    VlanId != null &&
                    VlanId.Equals(other.VlanId)
                ) && 
                (
                    Gateway == other.Gateway ||
                    Gateway != null &&
                    Gateway.Equals(other.Gateway)
                ) && 
                (
                    PrefixLength == other.PrefixLength ||
                    PrefixLength != null &&
                    PrefixLength.Equals(other.PrefixLength)
                ) && 
                (
                    StorageDiscoveryAddress == other.StorageDiscoveryAddress ||
                    StorageDiscoveryAddress != null &&
                    StorageDiscoveryAddress.Equals(other.StorageDiscoveryAddress)
                ) && 
                (
                    ClusterMgmtAddress == other.ClusterMgmtAddress ||
                    ClusterMgmtAddress != null &&
                    ClusterMgmtAddress.Equals(other.ClusterMgmtAddress)
                ) && 
                (
                    Mtu == other.Mtu ||
                    Mtu != null &&
                    Mtu.Equals(other.Mtu)
                ) && 
                (
                    AddAddresses == other.AddAddresses ||
                    AddAddresses != null &&
                    AddAddresses.SequenceEqual(other.AddAddresses)
                ) && 
                (
                    NvmeDiscoveryMode == other.NvmeDiscoveryMode ||
                    NvmeDiscoveryMode != null &&
                    NvmeDiscoveryMode.Equals(other.NvmeDiscoveryMode)
                ) && 
                (
                    NvmeCdcAddress == other.NvmeCdcAddress ||
                    NvmeCdcAddress != null &&
                    NvmeCdcAddress.Equals(other.NvmeCdcAddress)
                ) && 
                (
                    NvmeCdcPort == other.NvmeCdcPort ||
                    NvmeCdcPort != null &&
                    NvmeCdcPort.Equals(other.NvmeCdcPort)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Type != null)
                    hashCode = hashCode * 59 + Type.GetHashCode();
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (IpVersion != null)
                    hashCode = hashCode * 59 + IpVersion.GetHashCode();
                    if (Purposes != null)
                    hashCode = hashCode * 59 + Purposes.GetHashCode();
                    if (VlanId != null)
                    hashCode = hashCode * 59 + VlanId.GetHashCode();
                    if (Gateway != null)
                    hashCode = hashCode * 59 + Gateway.GetHashCode();
                    if (PrefixLength != null)
                    hashCode = hashCode * 59 + PrefixLength.GetHashCode();
                    if (StorageDiscoveryAddress != null)
                    hashCode = hashCode * 59 + StorageDiscoveryAddress.GetHashCode();
                    if (ClusterMgmtAddress != null)
                    hashCode = hashCode * 59 + ClusterMgmtAddress.GetHashCode();
                    if (Mtu != null)
                    hashCode = hashCode * 59 + Mtu.GetHashCode();
                    if (AddAddresses != null)
                    hashCode = hashCode * 59 + AddAddresses.GetHashCode();
                    if (NvmeDiscoveryMode != null)
                    hashCode = hashCode * 59 + NvmeDiscoveryMode.GetHashCode();
                    if (NvmeCdcAddress != null)
                    hashCode = hashCode * 59 + NvmeCdcAddress.GetHashCode();
                    if (NvmeCdcPort != null)
                    hashCode = hashCode * 59 + NvmeCdcPort.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(NetworkCreate left, NetworkCreate right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(NetworkCreate left, NetworkCreate right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
