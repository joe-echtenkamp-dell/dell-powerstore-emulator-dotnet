/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// Parameters of the NAS server clone operation. Was added in version 3.0.0.0.
    /// </summary>
    [DataContract]
    public partial class NasServerClone : IEquatable<NasServerClone>
    { 
        /// <summary>
        /// The name for the cloned NAS server.
        /// </summary>
        /// <value>The name for the cloned NAS server.</value>
        [Required]
        
        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// The list of File systems to clone.
        /// </summary>
        /// <value>The list of File systems to clone.</value>

        [DataMember(Name="file_systems")]
        public List<string> FileSystems { get; set; }

        /// <summary>
        /// Specifies whether cloning of FLR-C user file system should be allowed.
        /// </summary>
        /// <value>Specifies whether cloning of FLR-C user file system should be allowed.</value>

        [DataMember(Name="clone_flr_file_systems")]
        public bool? CloneFlrFileSystems { get; set; }

        /// <summary>
        /// Cloning a replicated NAS server destination with the Disaster Recovery Testing option enabled allows for an independent copy of the NAS server to be instantiated so that full DR testing can be done against the clone. The DR test clone will not interfere with the production NAS server, nor will it interfere with the cloned destination should an actual failover occur while the DR test clone is active.  This relies on the clone having a completely isolated network from both the source and destination NAS servers of the replication. The DR test clone will have the same IP addresses as the cloned destination NAS server, so they cannot coexist on the same network. This means that port assignment to the clone must use ports that are not routable to the ports of the replicated destination NAS server.  Was added in version 3.6.0.0.
        /// </summary>
        /// <value>Cloning a replicated NAS server destination with the Disaster Recovery Testing option enabled allows for an independent copy of the NAS server to be instantiated so that full DR testing can be done against the clone. The DR test clone will not interfere with the production NAS server, nor will it interfere with the cloned destination should an actual failover occur while the DR test clone is active.  This relies on the clone having a completely isolated network from both the source and destination NAS servers of the replication. The DR test clone will have the same IP addresses as the cloned destination NAS server, so they cannot coexist on the same network. This means that port assignment to the clone must use ports that are not routable to the ports of the replicated destination NAS server.  Was added in version 3.6.0.0.</value>

        [DataMember(Name="is_dr_test")]
        public bool? IsDrTest { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NasServerClone {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  FileSystems: ").Append(FileSystems).Append("\n");
            sb.Append("  CloneFlrFileSystems: ").Append(CloneFlrFileSystems).Append("\n");
            sb.Append("  IsDrTest: ").Append(IsDrTest).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((NasServerClone)obj);
        }

        /// <summary>
        /// Returns true if NasServerClone instances are equal
        /// </summary>
        /// <param name="other">Instance of NasServerClone to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NasServerClone other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    FileSystems == other.FileSystems ||
                    FileSystems != null &&
                    FileSystems.SequenceEqual(other.FileSystems)
                ) && 
                (
                    CloneFlrFileSystems == other.CloneFlrFileSystems ||
                    CloneFlrFileSystems != null &&
                    CloneFlrFileSystems.Equals(other.CloneFlrFileSystems)
                ) && 
                (
                    IsDrTest == other.IsDrTest ||
                    IsDrTest != null &&
                    IsDrTest.Equals(other.IsDrTest)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (FileSystems != null)
                    hashCode = hashCode * 59 + FileSystems.GetHashCode();
                    if (CloneFlrFileSystems != null)
                    hashCode = hashCode * 59 + CloneFlrFileSystems.GetHashCode();
                    if (IsDrTest != null)
                    hashCode = hashCode * 59 + IsDrTest.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(NasServerClone left, NasServerClone right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(NasServerClone left, NasServerClone right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
