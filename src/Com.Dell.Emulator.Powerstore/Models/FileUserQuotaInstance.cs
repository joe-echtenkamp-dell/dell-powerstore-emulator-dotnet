/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Com.Dell.Emulator.Powerstore.Models
{ 
    /// <summary>
    /// This resource type has queriable associations from file_system, file_tree_quota
    /// </summary>
    [DataContract]
    public partial class FileUserQuotaInstance : IEquatable<FileUserQuotaInstance>
    { 
        /// <summary>
        /// Unique identifier of the user quota.
        /// </summary>
        /// <value>Unique identifier of the user quota.</value>

        [DataMember(Name="id")]
        public string Id { get; private set; }

        /// <summary>
        /// Unique identifier of the associated filesystem.
        /// </summary>
        /// <value>Unique identifier of the associated filesystem.</value>

        [DataMember(Name="file_system_id")]
        public string FileSystemId { get; set; }

        /// <summary>
        /// Unique identifier of the associated tree quota. Values are: - null - if the user quota is not within a quota tree. - tree_quota instance id - if the user quota is within a quota tree. 
        /// </summary>
        /// <value>Unique identifier of the associated tree quota. Values are: - null - if the user quota is not within a quota tree. - tree_quota instance id - if the user quota is within a quota tree. </value>

        [DataMember(Name="tree_quota_id")]
        public string TreeQuotaId { get; set; }

        /// <summary>
        /// Unix user identifier (UID) of the user.
        /// </summary>
        /// <value>Unix user identifier (UID) of the user.</value>

        [Range(1, 4294967294)]
        [DataMember(Name="uid")]
        public long? Uid { get; set; }

        /// <summary>
        /// Unix username.
        /// </summary>
        /// <value>Unix username.</value>

        [DataMember(Name="unix_name")]
        public string UnixName { get; set; }

        /// <summary>
        /// Windows username. The format is domain\\\\user for the domain user.
        /// </summary>
        /// <value>Windows username. The format is domain\\\\user for the domain user.</value>

        [DataMember(Name="windows_name")]
        public string WindowsName { get; set; }

        /// <summary>
        /// Windows Security Identifier of the user.
        /// </summary>
        /// <value>Windows Security Identifier of the user.</value>

        [DataMember(Name="windows_sid")]
        public string WindowsSid { get; set; }

        /// <summary>
        /// Gets or Sets State
        /// </summary>

        [DataMember(Name="state")]
        public FileQuotaStateEnum? State { get; set; }

        /// <summary>
        /// Hard limit of the user quota, in bytes. No hard limit when set to 0. This value can be used to compute amount of space that is consumed without limiting the space.
        /// </summary>
        /// <value>Hard limit of the user quota, in bytes. No hard limit when set to 0. This value can be used to compute amount of space that is consumed without limiting the space.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="hard_limit")]
        public long? HardLimit { get; set; }

        /// <summary>
        /// Soft limit of the user quota, in bytes. No hard limit when set to 0.
        /// </summary>
        /// <value>Soft limit of the user quota, in bytes. No hard limit when set to 0.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="soft_limit")]
        public long? SoftLimit { get; set; }

        /// <summary>
        /// Remaining grace period, in seconds, after the soft limit is exceeded:   - 0 - Grace period has already expired   - -1 - No grace period in-progress, or infinite grace period set The grace period of user quotas is set in the file system quota configuration. 
        /// </summary>
        /// <value>Remaining grace period, in seconds, after the soft limit is exceeded:   - 0 - Grace period has already expired   - -1 - No grace period in-progress, or infinite grace period set The grace period of user quotas is set in the file system quota configuration. </value>

        [Range(0, 2147483647)]
        [DataMember(Name="remaining_grace_period")]
        public int? RemainingGracePeriod { get; set; }

        /// <summary>
        /// Size currently consumed by the user on the filesystem, in bytes.
        /// </summary>
        /// <value>Size currently consumed by the user on the filesystem, in bytes.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="size_used")]
        public long? SizeUsed { get; set; }

        /// <summary>
        /// Localized message string corresponding to state
        /// </summary>
        /// <value>Localized message string corresponding to state</value>

        [DataMember(Name="state_l10n")]
        public string StateL10n { get; set; }

        /// <summary>
        /// This is the embeddable reference form of file_system_id attribute.
        /// </summary>
        /// <value>This is the embeddable reference form of file_system_id attribute.</value>

        [DataMember(Name="file_system")]
        public FileSystemInstance FileSystem { get; set; }

        /// <summary>
        /// This is the embeddable reference form of tree_quota_id attribute.
        /// </summary>
        /// <value>This is the embeddable reference form of tree_quota_id attribute.</value>

        [DataMember(Name="tree_quota")]
        public FileTreeQuotaInstance TreeQuota { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class FileUserQuotaInstance {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  FileSystemId: ").Append(FileSystemId).Append("\n");
            sb.Append("  TreeQuotaId: ").Append(TreeQuotaId).Append("\n");
            sb.Append("  Uid: ").Append(Uid).Append("\n");
            sb.Append("  UnixName: ").Append(UnixName).Append("\n");
            sb.Append("  WindowsName: ").Append(WindowsName).Append("\n");
            sb.Append("  WindowsSid: ").Append(WindowsSid).Append("\n");
            sb.Append("  State: ").Append(State).Append("\n");
            sb.Append("  HardLimit: ").Append(HardLimit).Append("\n");
            sb.Append("  SoftLimit: ").Append(SoftLimit).Append("\n");
            sb.Append("  RemainingGracePeriod: ").Append(RemainingGracePeriod).Append("\n");
            sb.Append("  SizeUsed: ").Append(SizeUsed).Append("\n");
            sb.Append("  StateL10n: ").Append(StateL10n).Append("\n");
            sb.Append("  FileSystem: ").Append(FileSystem).Append("\n");
            sb.Append("  TreeQuota: ").Append(TreeQuota).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((FileUserQuotaInstance)obj);
        }

        /// <summary>
        /// Returns true if FileUserQuotaInstance instances are equal
        /// </summary>
        /// <param name="other">Instance of FileUserQuotaInstance to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FileUserQuotaInstance other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Id == other.Id ||
                    Id != null &&
                    Id.Equals(other.Id)
                ) && 
                (
                    FileSystemId == other.FileSystemId ||
                    FileSystemId != null &&
                    FileSystemId.Equals(other.FileSystemId)
                ) && 
                (
                    TreeQuotaId == other.TreeQuotaId ||
                    TreeQuotaId != null &&
                    TreeQuotaId.Equals(other.TreeQuotaId)
                ) && 
                (
                    Uid == other.Uid ||
                    Uid != null &&
                    Uid.Equals(other.Uid)
                ) && 
                (
                    UnixName == other.UnixName ||
                    UnixName != null &&
                    UnixName.Equals(other.UnixName)
                ) && 
                (
                    WindowsName == other.WindowsName ||
                    WindowsName != null &&
                    WindowsName.Equals(other.WindowsName)
                ) && 
                (
                    WindowsSid == other.WindowsSid ||
                    WindowsSid != null &&
                    WindowsSid.Equals(other.WindowsSid)
                ) && 
                (
                    State == other.State ||
                    State != null &&
                    State.Equals(other.State)
                ) && 
                (
                    HardLimit == other.HardLimit ||
                    HardLimit != null &&
                    HardLimit.Equals(other.HardLimit)
                ) && 
                (
                    SoftLimit == other.SoftLimit ||
                    SoftLimit != null &&
                    SoftLimit.Equals(other.SoftLimit)
                ) && 
                (
                    RemainingGracePeriod == other.RemainingGracePeriod ||
                    RemainingGracePeriod != null &&
                    RemainingGracePeriod.Equals(other.RemainingGracePeriod)
                ) && 
                (
                    SizeUsed == other.SizeUsed ||
                    SizeUsed != null &&
                    SizeUsed.Equals(other.SizeUsed)
                ) && 
                (
                    StateL10n == other.StateL10n ||
                    StateL10n != null &&
                    StateL10n.Equals(other.StateL10n)
                ) && 
                (
                    FileSystem == other.FileSystem ||
                    FileSystem != null &&
                    FileSystem.Equals(other.FileSystem)
                ) && 
                (
                    TreeQuota == other.TreeQuota ||
                    TreeQuota != null &&
                    TreeQuota.Equals(other.TreeQuota)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Id != null)
                    hashCode = hashCode * 59 + Id.GetHashCode();
                    if (FileSystemId != null)
                    hashCode = hashCode * 59 + FileSystemId.GetHashCode();
                    if (TreeQuotaId != null)
                    hashCode = hashCode * 59 + TreeQuotaId.GetHashCode();
                    if (Uid != null)
                    hashCode = hashCode * 59 + Uid.GetHashCode();
                    if (UnixName != null)
                    hashCode = hashCode * 59 + UnixName.GetHashCode();
                    if (WindowsName != null)
                    hashCode = hashCode * 59 + WindowsName.GetHashCode();
                    if (WindowsSid != null)
                    hashCode = hashCode * 59 + WindowsSid.GetHashCode();
                    if (State != null)
                    hashCode = hashCode * 59 + State.GetHashCode();
                    if (HardLimit != null)
                    hashCode = hashCode * 59 + HardLimit.GetHashCode();
                    if (SoftLimit != null)
                    hashCode = hashCode * 59 + SoftLimit.GetHashCode();
                    if (RemainingGracePeriod != null)
                    hashCode = hashCode * 59 + RemainingGracePeriod.GetHashCode();
                    if (SizeUsed != null)
                    hashCode = hashCode * 59 + SizeUsed.GetHashCode();
                    if (StateL10n != null)
                    hashCode = hashCode * 59 + StateL10n.GetHashCode();
                    if (FileSystem != null)
                    hashCode = hashCode * 59 + FileSystem.GetHashCode();
                    if (TreeQuota != null)
                    hashCode = hashCode * 59 + TreeQuota.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(FileUserQuotaInstance left, FileUserQuotaInstance right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(FileUserQuotaInstance left, FileUserQuotaInstance right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
