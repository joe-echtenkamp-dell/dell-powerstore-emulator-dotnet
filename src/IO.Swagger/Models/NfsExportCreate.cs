/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class NfsExportCreate : IEquatable<NfsExportCreate>
    { 
        /// <summary>
        /// Unique identifier of the file system on which the NFS Export will be created. name:{name} can be used instead of {id}. For example: &#39;file_system_id&#39;:&#39;name:file_system_name&#39;
        /// </summary>
        /// <value>Unique identifier of the file system on which the NFS Export will be created. name:{name} can be used instead of {id}. For example: &#39;file_system_id&#39;:&#39;name:file_system_name&#39;</value>
        [Required]
        
        [DataMember(Name="file_system_id")]
        public string FileSystemId { get; set; }

        /// <summary>
        /// Local path to export relative to the file system root directory. With NFS, each export of a file_system or file_snap must have a unique local path. Before you can create additional Exports within an NFS shared folder, you must create directories within it from a Linux/Unix host that is connected to the file system. After a directory has been created from a mounted host, you can create a corresponding Export and set access permissions accordingly. 
        /// </summary>
        /// <value>Local path to export relative to the file system root directory. With NFS, each export of a file_system or file_snap must have a unique local path. Before you can create additional Exports within an NFS shared folder, you must create directories within it from a Linux/Unix host that is connected to the file system. After a directory has been created from a mounted host, you can create a corresponding Export and set access permissions accordingly. </value>
        [Required]
        
        [StringLength(1023, MinimumLength=1)]
        [DataMember(Name="path")]
        public string Path { get; set; }

        /// <summary>
        /// NFS Export name.
        /// </summary>
        /// <value>NFS Export name.</value>
        [Required]
        
        [StringLength(255, MinimumLength=1)]
        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// User defined NFS Export description.
        /// </summary>
        /// <value>User defined NFS Export description.</value>

        [StringLength(511, MinimumLength=0)]
        [DataMember(Name="description")]
        public string Description { get; set; }

        /// <summary>
        /// Gets or Sets DefaultAccess
        /// </summary>

        [DataMember(Name="default_access")]
        public NFSExportDefaultAccessEnum? DefaultAccess { get; set; }

        /// <summary>
        /// Gets or Sets MinSecurity
        /// </summary>

        [DataMember(Name="min_security")]
        public NFSExportMinSecurityEnum? MinSecurity { get; set; }

        /// <summary>
        /// Hosts with no access to the NFS export or its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.
        /// </summary>
        /// <value>Hosts with no access to the NFS export or its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.</value>

        [DataMember(Name="no_access_hosts")]
        public List<string> NoAccessHosts { get; set; }

        /// <summary>
        /// Hosts with read-only access to the NFS export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.
        /// </summary>
        /// <value>Hosts with read-only access to the NFS export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.</value>

        [DataMember(Name="read_only_hosts")]
        public List<string> ReadOnlyHosts { get; set; }

        /// <summary>
        /// Hosts with read-only and ready-only for root user access to the NFS Export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.
        /// </summary>
        /// <value>Hosts with read-only and ready-only for root user access to the NFS Export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.</value>

        [DataMember(Name="read_only_root_hosts")]
        public List<string> ReadOnlyRootHosts { get; set; }

        /// <summary>
        /// Hosts with read and write access to the NFS export and its snapshots.Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.
        /// </summary>
        /// <value>Hosts with read and write access to the NFS export and its snapshots.Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.</value>

        [DataMember(Name="read_write_hosts")]
        public List<string> ReadWriteHosts { get; set; }

        /// <summary>
        /// Hosts with read and write and read and write for root user access to the NFS Export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.
        /// </summary>
        /// <value>Hosts with read and write and read and write for root user access to the NFS Export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @. The maximum length of an Host name is 255 bytes, and the sum of lengths of all the items in the list is limited to 4096 bytes.</value>

        [DataMember(Name="read_write_root_hosts")]
        public List<string> ReadWriteRootHosts { get; set; }

        /// <summary>
        /// Specifies the user ID of the anonymous account.
        /// </summary>
        /// <value>Specifies the user ID of the anonymous account.</value>

        [Range(-2147483648, 2147483647)]
        [DataMember(Name="anonymous_UID")]
        public int? AnonymousUID { get; set; }

        /// <summary>
        /// Specifies the group ID of the anonymous account.
        /// </summary>
        /// <value>Specifies the group ID of the anonymous account.</value>

        [Range(-2147483648, 2147483647)]
        [DataMember(Name="anonymous_GID")]
        public int? AnonymousGID { get; set; }

        /// <summary>
        /// If set, do not allow access to set SUID. Otherwise, allow access.
        /// </summary>
        /// <value>If set, do not allow access to set SUID. Otherwise, allow access.</value>

        [DataMember(Name="is_no_SUID")]
        public bool? IsNoSUID { get; set; }

        /// <summary>
        /// (*Applies to NFS shares of VMware NFS storage resources.*) Default owner of the NFS Export associated with the datastore. Required if secure NFS enabled. For NFSv3 or NFSv4 without Kerberos, the default owner is root. Was added in version 3.0.0.0.
        /// </summary>
        /// <value>(*Applies to NFS shares of VMware NFS storage resources.*) Default owner of the NFS Export associated with the datastore. Required if secure NFS enabled. For NFSv3 or NFSv4 without Kerberos, the default owner is root. Was added in version 3.0.0.0.</value>

        [StringLength(32, MinimumLength=0)]
        [DataMember(Name="nfs_owner_username")]
        public string NfsOwnerUsername { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NfsExportCreate {\n");
            sb.Append("  FileSystemId: ").Append(FileSystemId).Append("\n");
            sb.Append("  Path: ").Append(Path).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  DefaultAccess: ").Append(DefaultAccess).Append("\n");
            sb.Append("  MinSecurity: ").Append(MinSecurity).Append("\n");
            sb.Append("  NoAccessHosts: ").Append(NoAccessHosts).Append("\n");
            sb.Append("  ReadOnlyHosts: ").Append(ReadOnlyHosts).Append("\n");
            sb.Append("  ReadOnlyRootHosts: ").Append(ReadOnlyRootHosts).Append("\n");
            sb.Append("  ReadWriteHosts: ").Append(ReadWriteHosts).Append("\n");
            sb.Append("  ReadWriteRootHosts: ").Append(ReadWriteRootHosts).Append("\n");
            sb.Append("  AnonymousUID: ").Append(AnonymousUID).Append("\n");
            sb.Append("  AnonymousGID: ").Append(AnonymousGID).Append("\n");
            sb.Append("  IsNoSUID: ").Append(IsNoSUID).Append("\n");
            sb.Append("  NfsOwnerUsername: ").Append(NfsOwnerUsername).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((NfsExportCreate)obj);
        }

        /// <summary>
        /// Returns true if NfsExportCreate instances are equal
        /// </summary>
        /// <param name="other">Instance of NfsExportCreate to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NfsExportCreate other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    FileSystemId == other.FileSystemId ||
                    FileSystemId != null &&
                    FileSystemId.Equals(other.FileSystemId)
                ) && 
                (
                    Path == other.Path ||
                    Path != null &&
                    Path.Equals(other.Path)
                ) && 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    Description == other.Description ||
                    Description != null &&
                    Description.Equals(other.Description)
                ) && 
                (
                    DefaultAccess == other.DefaultAccess ||
                    DefaultAccess != null &&
                    DefaultAccess.Equals(other.DefaultAccess)
                ) && 
                (
                    MinSecurity == other.MinSecurity ||
                    MinSecurity != null &&
                    MinSecurity.Equals(other.MinSecurity)
                ) && 
                (
                    NoAccessHosts == other.NoAccessHosts ||
                    NoAccessHosts != null &&
                    NoAccessHosts.SequenceEqual(other.NoAccessHosts)
                ) && 
                (
                    ReadOnlyHosts == other.ReadOnlyHosts ||
                    ReadOnlyHosts != null &&
                    ReadOnlyHosts.SequenceEqual(other.ReadOnlyHosts)
                ) && 
                (
                    ReadOnlyRootHosts == other.ReadOnlyRootHosts ||
                    ReadOnlyRootHosts != null &&
                    ReadOnlyRootHosts.SequenceEqual(other.ReadOnlyRootHosts)
                ) && 
                (
                    ReadWriteHosts == other.ReadWriteHosts ||
                    ReadWriteHosts != null &&
                    ReadWriteHosts.SequenceEqual(other.ReadWriteHosts)
                ) && 
                (
                    ReadWriteRootHosts == other.ReadWriteRootHosts ||
                    ReadWriteRootHosts != null &&
                    ReadWriteRootHosts.SequenceEqual(other.ReadWriteRootHosts)
                ) && 
                (
                    AnonymousUID == other.AnonymousUID ||
                    AnonymousUID != null &&
                    AnonymousUID.Equals(other.AnonymousUID)
                ) && 
                (
                    AnonymousGID == other.AnonymousGID ||
                    AnonymousGID != null &&
                    AnonymousGID.Equals(other.AnonymousGID)
                ) && 
                (
                    IsNoSUID == other.IsNoSUID ||
                    IsNoSUID != null &&
                    IsNoSUID.Equals(other.IsNoSUID)
                ) && 
                (
                    NfsOwnerUsername == other.NfsOwnerUsername ||
                    NfsOwnerUsername != null &&
                    NfsOwnerUsername.Equals(other.NfsOwnerUsername)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (FileSystemId != null)
                    hashCode = hashCode * 59 + FileSystemId.GetHashCode();
                    if (Path != null)
                    hashCode = hashCode * 59 + Path.GetHashCode();
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (Description != null)
                    hashCode = hashCode * 59 + Description.GetHashCode();
                    if (DefaultAccess != null)
                    hashCode = hashCode * 59 + DefaultAccess.GetHashCode();
                    if (MinSecurity != null)
                    hashCode = hashCode * 59 + MinSecurity.GetHashCode();
                    if (NoAccessHosts != null)
                    hashCode = hashCode * 59 + NoAccessHosts.GetHashCode();
                    if (ReadOnlyHosts != null)
                    hashCode = hashCode * 59 + ReadOnlyHosts.GetHashCode();
                    if (ReadOnlyRootHosts != null)
                    hashCode = hashCode * 59 + ReadOnlyRootHosts.GetHashCode();
                    if (ReadWriteHosts != null)
                    hashCode = hashCode * 59 + ReadWriteHosts.GetHashCode();
                    if (ReadWriteRootHosts != null)
                    hashCode = hashCode * 59 + ReadWriteRootHosts.GetHashCode();
                    if (AnonymousUID != null)
                    hashCode = hashCode * 59 + AnonymousUID.GetHashCode();
                    if (AnonymousGID != null)
                    hashCode = hashCode * 59 + AnonymousGID.GetHashCode();
                    if (IsNoSUID != null)
                    hashCode = hashCode * 59 + IsNoSUID.GetHashCode();
                    if (NfsOwnerUsername != null)
                    hashCode = hashCode * 59 + NfsOwnerUsername.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(NfsExportCreate left, NfsExportCreate right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(NfsExportCreate left, NfsExportCreate right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
