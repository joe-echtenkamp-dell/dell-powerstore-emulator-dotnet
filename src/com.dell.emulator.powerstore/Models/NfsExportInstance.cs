/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Com.Dell.Emulator.Powerstore.Models
{ 
    /// <summary>
    /// This resource type has queriable associations from file_system, datastore
    /// </summary>
    [DataContract]
    public partial class NfsExportInstance : IEquatable<NfsExportInstance>
    { 
        /// <summary>
        /// Unique id of the NFS Export.
        /// </summary>
        /// <value>Unique id of the NFS Export.</value>

        [DataMember(Name="id")]
        public string Id { get; set; }

        /// <summary>
        /// Unique identifier of the file system on which the NFS Export was created.
        /// </summary>
        /// <value>Unique identifier of the file system on which the NFS Export was created.</value>

        [DataMember(Name="file_system_id")]
        public string FileSystemId { get; set; }

        /// <summary>
        /// NFS Export name.  This property supports case-insensitive filtering.
        /// </summary>
        /// <value>NFS Export name.  This property supports case-insensitive filtering.</value>

        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// Local path to a location within the file system. With NFS, each export must have a unique local path. By default, the system exports the root of the file system (top-most directory) at the time the file system is created. This path specifies the unique location of the file system on the storage system. Before you can create additional exports within an NFS shared folder, you must create directories within it from a Linux/Unix host that is connected to the file system. After a directory has been created from a mounted host, you can create a corresponding export and set access permissions accordingly. 
        /// </summary>
        /// <value>Local path to a location within the file system. With NFS, each export must have a unique local path. By default, the system exports the root of the file system (top-most directory) at the time the file system is created. This path specifies the unique location of the file system on the storage system. Before you can create additional exports within an NFS shared folder, you must create directories within it from a Linux/Unix host that is connected to the file system. After a directory has been created from a mounted host, you can create a corresponding export and set access permissions accordingly. </value>

        [DataMember(Name="path")]
        public string Path { get; set; }

        /// <summary>
        /// NFS Export description.
        /// </summary>
        /// <value>NFS Export description.</value>

        [DataMember(Name="description")]
        public string Description { get; set; }

        /// <summary>
        /// Gets or Sets DefaultAccess
        /// </summary>

        [DataMember(Name="default_access")]
        public NFSExportDefaultAccessEnum? DefaultAccess { get; set; }

        /// <summary>
        /// Gets or Sets MinSecurity
        /// </summary>

        [DataMember(Name="min_security")]
        public NFSExportMinSecurityEnum? MinSecurity { get; set; }

        /// <summary>
        /// (*Applies to NFS shares of VMware NFS storage resources.*) Default owner of the NFS Export associated with the datastore. Required if secure NFS enabled. For NFSv3 or NFSv4 without Kerberos, the default owner is root.
        /// </summary>
        /// <value>(*Applies to NFS shares of VMware NFS storage resources.*) Default owner of the NFS Export associated with the datastore. Required if secure NFS enabled. For NFSv3 or NFSv4 without Kerberos, the default owner is root.</value>

        [DataMember(Name="nfs_owner_username")]
        public string NfsOwnerUsername { get; set; }

        /// <summary>
        /// Hosts with no access to the NFS export or its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.
        /// </summary>
        /// <value>Hosts with no access to the NFS export or its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.</value>

        [DataMember(Name="no_access_hosts")]
        public List<string> NoAccessHosts { get; set; }

        /// <summary>
        /// Hosts with read-only access to the NFS export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.
        /// </summary>
        /// <value>Hosts with read-only access to the NFS export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.</value>

        [DataMember(Name="read_only_hosts")]
        public List<string> ReadOnlyHosts { get; set; }

        /// <summary>
        /// Hosts with read-only and ready-only for root user access to the NFS Export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.
        /// </summary>
        /// <value>Hosts with read-only and ready-only for root user access to the NFS Export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.</value>

        [DataMember(Name="read_only_root_hosts")]
        public List<string> ReadOnlyRootHosts { get; set; }

        /// <summary>
        /// Hosts with read and write access to the NFS export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.
        /// </summary>
        /// <value>Hosts with read and write access to the NFS export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.</value>

        [DataMember(Name="read_write_hosts")]
        public List<string> ReadWriteHosts { get; set; }

        /// <summary>
        /// Hosts with read and write and read and write for root user access to the NFS Export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.
        /// </summary>
        /// <value>Hosts with read and write and read and write for root user access to the NFS Export and its snapshots. Hosts can be entered by Hostname, IP addresses (IPv4, IPv6, IPv4/PrefixLength, IPv6/PrefixLenght, or IPv4/subnetmask), or Netgroups prefixed with @.</value>

        [DataMember(Name="read_write_root_hosts")]
        public List<string> ReadWriteRootHosts { get; set; }

        /// <summary>
        /// Specifies the user ID of the anonymous account.
        /// </summary>
        /// <value>Specifies the user ID of the anonymous account.</value>

        [Range(-2147483648, 2147483647)]
        [DataMember(Name="anonymous_UID")]
        public int? AnonymousUID { get; set; }

        /// <summary>
        /// Specifies the group ID of the anonymous account.
        /// </summary>
        /// <value>Specifies the group ID of the anonymous account.</value>

        [Range(-2147483648, 2147483647)]
        [DataMember(Name="anonymous_GID")]
        public int? AnonymousGID { get; set; }

        /// <summary>
        /// If set, do not allow access to set SUID. Otherwise, allow access.
        /// </summary>
        /// <value>If set, do not allow access to set SUID. Otherwise, allow access.</value>

        [DataMember(Name="is_no_SUID")]
        public bool? IsNoSUID { get; set; }

        /// <summary>
        /// Localized message string corresponding to default_access
        /// </summary>
        /// <value>Localized message string corresponding to default_access</value>

        [DataMember(Name="default_access_l10n")]
        public string DefaultAccessL10n { get; set; }

        /// <summary>
        /// Localized message string corresponding to min_security
        /// </summary>
        /// <value>Localized message string corresponding to min_security</value>

        [DataMember(Name="min_security_l10n")]
        public string MinSecurityL10n { get; set; }

        /// <summary>
        /// This is the embeddable reference form of file_system_id attribute.
        /// </summary>
        /// <value>This is the embeddable reference form of file_system_id attribute.</value>

        [DataMember(Name="file_system")]
        public FileSystemInstance FileSystem { get; set; }

        /// <summary>
        /// This is the inverse of the resource type datastore association.
        /// </summary>
        /// <value>This is the inverse of the resource type datastore association.</value>

        [DataMember(Name="datastores")]
        public List<DatastoreInstance> Datastores { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NfsExportInstance {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  FileSystemId: ").Append(FileSystemId).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Path: ").Append(Path).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  DefaultAccess: ").Append(DefaultAccess).Append("\n");
            sb.Append("  MinSecurity: ").Append(MinSecurity).Append("\n");
            sb.Append("  NfsOwnerUsername: ").Append(NfsOwnerUsername).Append("\n");
            sb.Append("  NoAccessHosts: ").Append(NoAccessHosts).Append("\n");
            sb.Append("  ReadOnlyHosts: ").Append(ReadOnlyHosts).Append("\n");
            sb.Append("  ReadOnlyRootHosts: ").Append(ReadOnlyRootHosts).Append("\n");
            sb.Append("  ReadWriteHosts: ").Append(ReadWriteHosts).Append("\n");
            sb.Append("  ReadWriteRootHosts: ").Append(ReadWriteRootHosts).Append("\n");
            sb.Append("  AnonymousUID: ").Append(AnonymousUID).Append("\n");
            sb.Append("  AnonymousGID: ").Append(AnonymousGID).Append("\n");
            sb.Append("  IsNoSUID: ").Append(IsNoSUID).Append("\n");
            sb.Append("  DefaultAccessL10n: ").Append(DefaultAccessL10n).Append("\n");
            sb.Append("  MinSecurityL10n: ").Append(MinSecurityL10n).Append("\n");
            sb.Append("  FileSystem: ").Append(FileSystem).Append("\n");
            sb.Append("  Datastores: ").Append(Datastores).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((NfsExportInstance)obj);
        }

        /// <summary>
        /// Returns true if NfsExportInstance instances are equal
        /// </summary>
        /// <param name="other">Instance of NfsExportInstance to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NfsExportInstance other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Id == other.Id ||
                    Id != null &&
                    Id.Equals(other.Id)
                ) && 
                (
                    FileSystemId == other.FileSystemId ||
                    FileSystemId != null &&
                    FileSystemId.Equals(other.FileSystemId)
                ) && 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    Path == other.Path ||
                    Path != null &&
                    Path.Equals(other.Path)
                ) && 
                (
                    Description == other.Description ||
                    Description != null &&
                    Description.Equals(other.Description)
                ) && 
                (
                    DefaultAccess == other.DefaultAccess ||
                    DefaultAccess != null &&
                    DefaultAccess.Equals(other.DefaultAccess)
                ) && 
                (
                    MinSecurity == other.MinSecurity ||
                    MinSecurity != null &&
                    MinSecurity.Equals(other.MinSecurity)
                ) && 
                (
                    NfsOwnerUsername == other.NfsOwnerUsername ||
                    NfsOwnerUsername != null &&
                    NfsOwnerUsername.Equals(other.NfsOwnerUsername)
                ) && 
                (
                    NoAccessHosts == other.NoAccessHosts ||
                    NoAccessHosts != null &&
                    NoAccessHosts.SequenceEqual(other.NoAccessHosts)
                ) && 
                (
                    ReadOnlyHosts == other.ReadOnlyHosts ||
                    ReadOnlyHosts != null &&
                    ReadOnlyHosts.SequenceEqual(other.ReadOnlyHosts)
                ) && 
                (
                    ReadOnlyRootHosts == other.ReadOnlyRootHosts ||
                    ReadOnlyRootHosts != null &&
                    ReadOnlyRootHosts.SequenceEqual(other.ReadOnlyRootHosts)
                ) && 
                (
                    ReadWriteHosts == other.ReadWriteHosts ||
                    ReadWriteHosts != null &&
                    ReadWriteHosts.SequenceEqual(other.ReadWriteHosts)
                ) && 
                (
                    ReadWriteRootHosts == other.ReadWriteRootHosts ||
                    ReadWriteRootHosts != null &&
                    ReadWriteRootHosts.SequenceEqual(other.ReadWriteRootHosts)
                ) && 
                (
                    AnonymousUID == other.AnonymousUID ||
                    AnonymousUID != null &&
                    AnonymousUID.Equals(other.AnonymousUID)
                ) && 
                (
                    AnonymousGID == other.AnonymousGID ||
                    AnonymousGID != null &&
                    AnonymousGID.Equals(other.AnonymousGID)
                ) && 
                (
                    IsNoSUID == other.IsNoSUID ||
                    IsNoSUID != null &&
                    IsNoSUID.Equals(other.IsNoSUID)
                ) && 
                (
                    DefaultAccessL10n == other.DefaultAccessL10n ||
                    DefaultAccessL10n != null &&
                    DefaultAccessL10n.Equals(other.DefaultAccessL10n)
                ) && 
                (
                    MinSecurityL10n == other.MinSecurityL10n ||
                    MinSecurityL10n != null &&
                    MinSecurityL10n.Equals(other.MinSecurityL10n)
                ) && 
                (
                    FileSystem == other.FileSystem ||
                    FileSystem != null &&
                    FileSystem.Equals(other.FileSystem)
                ) && 
                (
                    Datastores == other.Datastores ||
                    Datastores != null &&
                    Datastores.SequenceEqual(other.Datastores)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Id != null)
                    hashCode = hashCode * 59 + Id.GetHashCode();
                    if (FileSystemId != null)
                    hashCode = hashCode * 59 + FileSystemId.GetHashCode();
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (Path != null)
                    hashCode = hashCode * 59 + Path.GetHashCode();
                    if (Description != null)
                    hashCode = hashCode * 59 + Description.GetHashCode();
                    if (DefaultAccess != null)
                    hashCode = hashCode * 59 + DefaultAccess.GetHashCode();
                    if (MinSecurity != null)
                    hashCode = hashCode * 59 + MinSecurity.GetHashCode();
                    if (NfsOwnerUsername != null)
                    hashCode = hashCode * 59 + NfsOwnerUsername.GetHashCode();
                    if (NoAccessHosts != null)
                    hashCode = hashCode * 59 + NoAccessHosts.GetHashCode();
                    if (ReadOnlyHosts != null)
                    hashCode = hashCode * 59 + ReadOnlyHosts.GetHashCode();
                    if (ReadOnlyRootHosts != null)
                    hashCode = hashCode * 59 + ReadOnlyRootHosts.GetHashCode();
                    if (ReadWriteHosts != null)
                    hashCode = hashCode * 59 + ReadWriteHosts.GetHashCode();
                    if (ReadWriteRootHosts != null)
                    hashCode = hashCode * 59 + ReadWriteRootHosts.GetHashCode();
                    if (AnonymousUID != null)
                    hashCode = hashCode * 59 + AnonymousUID.GetHashCode();
                    if (AnonymousGID != null)
                    hashCode = hashCode * 59 + AnonymousGID.GetHashCode();
                    if (IsNoSUID != null)
                    hashCode = hashCode * 59 + IsNoSUID.GetHashCode();
                    if (DefaultAccessL10n != null)
                    hashCode = hashCode * 59 + DefaultAccessL10n.GetHashCode();
                    if (MinSecurityL10n != null)
                    hashCode = hashCode * 59 + MinSecurityL10n.GetHashCode();
                    if (FileSystem != null)
                    hashCode = hashCode * 59 + FileSystem.GetHashCode();
                    if (Datastores != null)
                    hashCode = hashCode * 59 + Datastores.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(NfsExportInstance left, NfsExportInstance right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(NfsExportInstance left, NfsExportInstance right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
