/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class FileVirusCheckerModify : IEquatable<FileVirusCheckerModify>
    { 
        /// <summary>
        /// Indicates whether the anti-virus service is enabled on this NAS server. Value are: - true - Anti-virus service is enabled. Each file created or modified by an SMB client is scanned by the third-party anti-virus servers. If a virus is detected, the access to the file system is denied. If third-party anti-virus servers are not available, according the policy, the access to the file systems is denied to prevent potential viruses propagation. - false - Anti-virus service is disabled. File systems of the NAS servers are available for access without virus checking. 
        /// </summary>
        /// <value>Indicates whether the anti-virus service is enabled on this NAS server. Value are: - true - Anti-virus service is enabled. Each file created or modified by an SMB client is scanned by the third-party anti-virus servers. If a virus is detected, the access to the file system is denied. If third-party anti-virus servers are not available, according the policy, the access to the file systems is denied to prevent potential viruses propagation. - false - Anti-virus service is disabled. File systems of the NAS servers are available for access without virus checking. </value>

        [DataMember(Name="is_enabled")]
        public bool? IsEnabled { get; set; }

        /// <summary>
        /// In order to modify the configuration of this resource when the associated NAS server is a replication destination, the is_destination_override_enabled flag must be set to true. When true, a virus checker config file may be uploaded on the destination to override the source virus checker config file. Values are:   true - Enable locally set configuration. A virus checker config file may be uploaded on the destination to override the source virus checker config file.   false - Revert to use the source configuration file. Source configuration file changes will propagate directly to this resource.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>In order to modify the configuration of this resource when the associated NAS server is a replication destination, the is_destination_override_enabled flag must be set to true. When true, a virus checker config file may be uploaded on the destination to override the source virus checker config file. Values are:   true - Enable locally set configuration. A virus checker config file may be uploaded on the destination to override the source virus checker config file.   false - Revert to use the source configuration file. Source configuration file changes will propagate directly to this resource.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="is_destination_override_enabled")]
        public bool? IsDestinationOverrideEnabled { get; set; }

        /// <summary>
        /// Virus Checker server IP addresses. The addresses may be IPv4 or IPv6 or FQDN. Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Virus Checker server IP addresses. The addresses may be IPv4 or IPv6 or FQDN. Was added in version 3.0.0.0.</value>

        [DataMember(Name="ip_addresses")]
        public List<string> IpAddresses { get; set; }

        /// <summary>
        /// Defines files and file extensions to be scanned. * and ? wildcards can be used:  * Asterix (*) matches one or more occurrences of any character  * Question mark (?) matches a single occurence or any character  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Defines files and file extensions to be scanned. * and ? wildcards can be used:  * Asterix (*) matches one or more occurrences of any character  * Question mark (?) matches a single occurence or any character  Was added in version 3.0.0.0.</value>

        [DataMember(Name="files_to_scan")]
        public List<string> FilesToScan { get; set; }

        /// <summary>
        /// Defines files or file extensions to exclude during scanning. * and ? wildcards can be used: * Asterix (*) matches one or more occurrences of any character * Question mark (?) matches a single occurence or any character  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Defines files or file extensions to exclude during scanning. * and ? wildcards can be used: * Asterix (*) matches one or more occurrences of any character * Question mark (?) matches a single occurence or any character  Was added in version 3.0.0.0.</value>

        [DataMember(Name="files_to_exclude")]
        public List<string> FilesToExclude { get; set; }

        /// <summary>
        /// Files that are larger than this size won&#39;t be sent to the virus checker. 0 means no limit. Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Files that are larger than this size won&#39;t be sent to the virus checker. 0 means no limit. Was added in version 3.0.0.0.</value>

        [Range(0, 4294967295)]
        [DataMember(Name="max_file_size")]
        public long? MaxFileSize { get; set; }

        /// <summary>
        /// Time, in seconds at which frequency the system will verify that the virus checkers are online. Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Time, in seconds at which frequency the system will verify that the virus checkers are online. Was added in version 3.0.0.0.</value>

        [Range(1, 3600)]
        [DataMember(Name="survey_time")]
        public int? SurveyTime { get; set; }

        /// <summary>
        ///  Was added in version 3.0.0.0.
        /// </summary>
        /// <value> Was added in version 3.0.0.0.</value>

        [DataMember(Name="offline_policy")]
        public FileVirusCheckerOfflinePolicyEnum? OfflinePolicy { get; set; }

        /// <summary>
        /// Send an event and block FS I/O when the number of requests waiting for checker is reaching this value. Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Send an event and block FS I/O when the number of requests waiting for checker is reaching this value. Was added in version 3.0.0.0.</value>

        [Range(4, 2000)]
        [DataMember(Name="high_watermark")]
        public int? HighWatermark { get; set; }

        /// <summary>
        /// Only applicable after the high water mark is reached. After the high_watermark has been reached, system will wait the number of request to go below low watermark value before sending an event and un-blocking FS I/O. Recommended value is 1/4th of high_watermark value.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Only applicable after the high water mark is reached. After the high_watermark has been reached, system will wait the number of request to go below low watermark value before sending an event and un-blocking FS I/O. Recommended value is 1/4th of high_watermark value.  Was added in version 3.0.0.0.</value>

        [Range(1, 500)]
        [DataMember(Name="low_watermark")]
        public int? LowWatermark { get; set; }

        /// <summary>
        /// User for authentication to the Virus checker server when msrpc request is enabled - MANDATORY IF MSRPC IS EMPLOYED (note that you can use the same user as the &#39;AV priviledged user&#39; for ease of use, but it could be a different user).  Was added in version 4.0.0.0.
        /// </summary>
        /// <value>User for authentication to the Virus checker server when msrpc request is enabled - MANDATORY IF MSRPC IS EMPLOYED (note that you can use the same user as the &#39;AV priviledged user&#39; for ease of use, but it could be a different user).  Was added in version 4.0.0.0.</value>

        [StringLength(1024, MinimumLength=1)]
        [DataMember(Name="msrpc_user")]
        public string MsrpcUser { get; set; }

        /// <summary>
        /// Password of the MS-RPC User  Was added in version 4.0.0.0.
        /// </summary>
        /// <value>Password of the MS-RPC User  Was added in version 4.0.0.0.</value>

        [StringLength(255, MinimumLength=1)]
        [DataMember(Name="msrpc_user_password")]
        public string MsrpcUserPassword { get; set; }

        /// <summary>
        /// Retry the file scan if the checker does not respond after this time (msrpc only). Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Retry the file scan if the checker does not respond after this time (msrpc only). Was added in version 3.0.0.0.</value>

        [Range(1, 3600000)]
        [DataMember(Name="rpc_retry_timeout")]
        public int? RpcRetryTimeout { get; set; }

        /// <summary>
        /// Time in milliseconds, during which the file scan will be retried (msrpc only). Recommended value is rpc_retry_timeout * 5.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Time in milliseconds, during which the file scan will be retried (msrpc only). Recommended value is rpc_retry_timeout * 5.  Was added in version 3.0.0.0.</value>

        [Range(1, 3600000)]
        [DataMember(Name="rpc_request_timeout")]
        public int? RpcRequestTimeout { get; set; }

        /// <summary>
        /// TCP port number used by the service to connect to the Virus checker server(s) with HTTP. Default port number is 12228. Set this http_port value to 0 to disable HTTP. When enabled, connection via HTTP is attempted first. If HTTP connection is disabled, or the connection fails, then connection through MSRPC is attempted if all Virus checker server(s) are defined by FQDN. The SMB account of the NAS server in the AD Domain is used to make the connection via MSRPC. Note that HTTP connections should only be used on secure networks, as it is neither SSL nor authenticated. Note: When the http_port is set, the same port number must be specified in the HttpPort entry of the Checker&#39;s Windows Registry at: HKEY_LOCAL_MACHINE\\SOFTWARE\\EMC\\CEE\\Configuration  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>TCP port number used by the service to connect to the Virus checker server(s) with HTTP. Default port number is 12228. Set this http_port value to 0 to disable HTTP. When enabled, connection via HTTP is attempted first. If HTTP connection is disabled, or the connection fails, then connection through MSRPC is attempted if all Virus checker server(s) are defined by FQDN. The SMB account of the NAS server in the AD Domain is used to make the connection via MSRPC. Note that HTTP connections should only be used on secure networks, as it is neither SSL nor authenticated. Note: When the http_port is set, the same port number must be specified in the HttpPort entry of the Checker&#39;s Windows Registry at: HKEY_LOCAL_MACHINE\\SOFTWARE\\EMC\\CEE\\Configuration  Was added in version 3.0.0.0.</value>

        [Range(0, 65535)]
        [DataMember(Name="http_port")]
        public int? HttpPort { get; set; }

        /// <summary>
        /// To enable scan on first read the reference time must be set. When the last access time of a file is earlier than the reference time, on access the file is sent to the Virus checker before the access is granted to the client.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>To enable scan on first read the reference time must be set. When the last access time of a file is earlier than the reference time, on access the file is sent to the Virus checker before the access is granted to the client.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="reference_time")]
        public DateTime? ReferenceTime { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class FileVirusCheckerModify {\n");
            sb.Append("  IsEnabled: ").Append(IsEnabled).Append("\n");
            sb.Append("  IsDestinationOverrideEnabled: ").Append(IsDestinationOverrideEnabled).Append("\n");
            sb.Append("  IpAddresses: ").Append(IpAddresses).Append("\n");
            sb.Append("  FilesToScan: ").Append(FilesToScan).Append("\n");
            sb.Append("  FilesToExclude: ").Append(FilesToExclude).Append("\n");
            sb.Append("  MaxFileSize: ").Append(MaxFileSize).Append("\n");
            sb.Append("  SurveyTime: ").Append(SurveyTime).Append("\n");
            sb.Append("  OfflinePolicy: ").Append(OfflinePolicy).Append("\n");
            sb.Append("  HighWatermark: ").Append(HighWatermark).Append("\n");
            sb.Append("  LowWatermark: ").Append(LowWatermark).Append("\n");
            sb.Append("  MsrpcUser: ").Append(MsrpcUser).Append("\n");
            sb.Append("  MsrpcUserPassword: ").Append(MsrpcUserPassword).Append("\n");
            sb.Append("  RpcRetryTimeout: ").Append(RpcRetryTimeout).Append("\n");
            sb.Append("  RpcRequestTimeout: ").Append(RpcRequestTimeout).Append("\n");
            sb.Append("  HttpPort: ").Append(HttpPort).Append("\n");
            sb.Append("  ReferenceTime: ").Append(ReferenceTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((FileVirusCheckerModify)obj);
        }

        /// <summary>
        /// Returns true if FileVirusCheckerModify instances are equal
        /// </summary>
        /// <param name="other">Instance of FileVirusCheckerModify to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FileVirusCheckerModify other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    IsEnabled == other.IsEnabled ||
                    IsEnabled != null &&
                    IsEnabled.Equals(other.IsEnabled)
                ) && 
                (
                    IsDestinationOverrideEnabled == other.IsDestinationOverrideEnabled ||
                    IsDestinationOverrideEnabled != null &&
                    IsDestinationOverrideEnabled.Equals(other.IsDestinationOverrideEnabled)
                ) && 
                (
                    IpAddresses == other.IpAddresses ||
                    IpAddresses != null &&
                    IpAddresses.SequenceEqual(other.IpAddresses)
                ) && 
                (
                    FilesToScan == other.FilesToScan ||
                    FilesToScan != null &&
                    FilesToScan.SequenceEqual(other.FilesToScan)
                ) && 
                (
                    FilesToExclude == other.FilesToExclude ||
                    FilesToExclude != null &&
                    FilesToExclude.SequenceEqual(other.FilesToExclude)
                ) && 
                (
                    MaxFileSize == other.MaxFileSize ||
                    MaxFileSize != null &&
                    MaxFileSize.Equals(other.MaxFileSize)
                ) && 
                (
                    SurveyTime == other.SurveyTime ||
                    SurveyTime != null &&
                    SurveyTime.Equals(other.SurveyTime)
                ) && 
                (
                    OfflinePolicy == other.OfflinePolicy ||
                    OfflinePolicy != null &&
                    OfflinePolicy.Equals(other.OfflinePolicy)
                ) && 
                (
                    HighWatermark == other.HighWatermark ||
                    HighWatermark != null &&
                    HighWatermark.Equals(other.HighWatermark)
                ) && 
                (
                    LowWatermark == other.LowWatermark ||
                    LowWatermark != null &&
                    LowWatermark.Equals(other.LowWatermark)
                ) && 
                (
                    MsrpcUser == other.MsrpcUser ||
                    MsrpcUser != null &&
                    MsrpcUser.Equals(other.MsrpcUser)
                ) && 
                (
                    MsrpcUserPassword == other.MsrpcUserPassword ||
                    MsrpcUserPassword != null &&
                    MsrpcUserPassword.Equals(other.MsrpcUserPassword)
                ) && 
                (
                    RpcRetryTimeout == other.RpcRetryTimeout ||
                    RpcRetryTimeout != null &&
                    RpcRetryTimeout.Equals(other.RpcRetryTimeout)
                ) && 
                (
                    RpcRequestTimeout == other.RpcRequestTimeout ||
                    RpcRequestTimeout != null &&
                    RpcRequestTimeout.Equals(other.RpcRequestTimeout)
                ) && 
                (
                    HttpPort == other.HttpPort ||
                    HttpPort != null &&
                    HttpPort.Equals(other.HttpPort)
                ) && 
                (
                    ReferenceTime == other.ReferenceTime ||
                    ReferenceTime != null &&
                    ReferenceTime.Equals(other.ReferenceTime)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (IsEnabled != null)
                    hashCode = hashCode * 59 + IsEnabled.GetHashCode();
                    if (IsDestinationOverrideEnabled != null)
                    hashCode = hashCode * 59 + IsDestinationOverrideEnabled.GetHashCode();
                    if (IpAddresses != null)
                    hashCode = hashCode * 59 + IpAddresses.GetHashCode();
                    if (FilesToScan != null)
                    hashCode = hashCode * 59 + FilesToScan.GetHashCode();
                    if (FilesToExclude != null)
                    hashCode = hashCode * 59 + FilesToExclude.GetHashCode();
                    if (MaxFileSize != null)
                    hashCode = hashCode * 59 + MaxFileSize.GetHashCode();
                    if (SurveyTime != null)
                    hashCode = hashCode * 59 + SurveyTime.GetHashCode();
                    if (OfflinePolicy != null)
                    hashCode = hashCode * 59 + OfflinePolicy.GetHashCode();
                    if (HighWatermark != null)
                    hashCode = hashCode * 59 + HighWatermark.GetHashCode();
                    if (LowWatermark != null)
                    hashCode = hashCode * 59 + LowWatermark.GetHashCode();
                    if (MsrpcUser != null)
                    hashCode = hashCode * 59 + MsrpcUser.GetHashCode();
                    if (MsrpcUserPassword != null)
                    hashCode = hashCode * 59 + MsrpcUserPassword.GetHashCode();
                    if (RpcRetryTimeout != null)
                    hashCode = hashCode * 59 + RpcRetryTimeout.GetHashCode();
                    if (RpcRequestTimeout != null)
                    hashCode = hashCode * 59 + RpcRequestTimeout.GetHashCode();
                    if (HttpPort != null)
                    hashCode = hashCode * 59 + HttpPort.GetHashCode();
                    if (ReferenceTime != null)
                    hashCode = hashCode * 59 + ReferenceTime.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(FileVirusCheckerModify left, FileVirusCheckerModify right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(FileVirusCheckerModify left, FileVirusCheckerModify right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
