/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Com.Dell.Emulator.Powerstore.Models
{ 
    /// <summary>
    /// This resource type has queriable associations from policy, file_interface, file_ndmp, file_virus_checker, nfs_server, smb_server, file_dns, file_ftp, file_kerberos, file_ldap, file_nis, file_system, file_dhsm_config, file_events_publisher
    /// </summary>
    [DataContract]
    public partial class NasServerInstance : IEquatable<NasServerInstance>
    { 
        /// <summary>
        /// Unique identifier of the NAS server.
        /// </summary>
        /// <value>Unique identifier of the NAS server.</value>

        [DataMember(Name="id")]
        public string Id { get; set; }

        /// <summary>
        /// Name of the NAS server.  This property supports case-insensitive filtering.
        /// </summary>
        /// <value>Name of the NAS server.  This property supports case-insensitive filtering.</value>

        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// Description of the NAS server.
        /// </summary>
        /// <value>Description of the NAS server.</value>

        [DataMember(Name="description")]
        public string Description { get; set; }

        /// <summary>
        /// Gets or Sets OperationalStatus
        /// </summary>

        [DataMember(Name="operational_status")]
        public NASServerOperationalStatusEnum? OperationalStatus { get; set; }

        /// <summary>
        /// Unique identifier of the node on which the NAS server is running.
        /// </summary>
        /// <value>Unique identifier of the node on which the NAS server is running.</value>

        [DataMember(Name="current_node_id")]
        public string CurrentNodeId { get; set; }

        /// <summary>
        /// Unique identifier of the preferred node for the NAS server The initial value (on NAS server creation) is taken from the current node.
        /// </summary>
        /// <value>Unique identifier of the preferred node for the NAS server The initial value (on NAS server creation) is taken from the current node.</value>

        [DataMember(Name="preferred_node_id")]
        public string PreferredNodeId { get; set; }

        /// <summary>
        /// Default Unix user name used for granting access in case of Windows to Unix user mapping failure. When empty, access in such case is denied.
        /// </summary>
        /// <value>Default Unix user name used for granting access in case of Windows to Unix user mapping failure. When empty, access in such case is denied.</value>

        [DataMember(Name="default_unix_user")]
        public string DefaultUnixUser { get; set; }

        /// <summary>
        /// Default Windows user name used for granting access in case of Unix to Windows user mapping failure. When empty, access in such case is denied.
        /// </summary>
        /// <value>Default Windows user name used for granting access in case of Unix to Windows user mapping failure. When empty, access in such case is denied.</value>

        [DataMember(Name="default_windows_user")]
        public string DefaultWindowsUser { get; set; }

        /// <summary>
        /// Gets or Sets CurrentUnixDirectoryService
        /// </summary>

        [DataMember(Name="current_unix_directory_service")]
        public NASServerCurrentUnixDirectoryServiceEnum? CurrentUnixDirectoryService { get; set; }

        /// <summary>
        /// Enable the possibility to match a windows account to a Unix account with different names.
        /// </summary>
        /// <value>Enable the possibility to match a windows account to a Unix account with different names.</value>

        [DataMember(Name="is_username_translation_enabled")]
        public bool? IsUsernameTranslationEnabled { get; set; }

        /// <summary>
        /// A Windows user must have a corresponding matching Unix user (uid) in order to connect. This attribute enables you to automatically generate this Unix user (uid), if that Windows user does not have any in the configured Unix directory service (UDS). In a pure SMB or non multi-protocol environment, this should be set to true. 
        /// </summary>
        /// <value>A Windows user must have a corresponding matching Unix user (uid) in order to connect. This attribute enables you to automatically generate this Unix user (uid), if that Windows user does not have any in the configured Unix directory service (UDS). In a pure SMB or non multi-protocol environment, this should be set to true. </value>

        [DataMember(Name="is_auto_user_mapping_enabled")]
        public bool? IsAutoUserMappingEnabled { get; set; }

        /// <summary>
        /// Unique identifier of the preferred IPv4 production interface.
        /// </summary>
        /// <value>Unique identifier of the preferred IPv4 production interface.</value>

        [DataMember(Name="production_IPv4_interface_id")]
        public string ProductionIPv4InterfaceId { get; set; }

        /// <summary>
        /// Unique identifier of the preferred IPv6 production interface.
        /// </summary>
        /// <value>Unique identifier of the preferred IPv6 production interface.</value>

        [DataMember(Name="production_IPv6_interface_id")]
        public string ProductionIPv6InterfaceId { get; set; }

        /// <summary>
        /// Unique identifier of the preferred IPv4 backup interface.
        /// </summary>
        /// <value>Unique identifier of the preferred IPv4 backup interface.</value>

        [DataMember(Name="backup_IPv4_interface_id")]
        public string BackupIPv4InterfaceId { get; set; }

        /// <summary>
        /// Unique identifier of the preferred IPv6 backup interface.
        /// </summary>
        /// <value>Unique identifier of the preferred IPv6 backup interface.</value>

        [DataMember(Name="backup_IPv6_interface_id")]
        public string BackupIPv6InterfaceId { get; set; }

        /// <summary>
        /// Unique identifier of the current active preferred IPv4 interface.
        /// </summary>
        /// <value>Unique identifier of the current active preferred IPv4 interface.</value>

        [DataMember(Name="current_preferred_IPv4_interface_id")]
        public string CurrentPreferredIPv4InterfaceId { get; set; }

        /// <summary>
        /// Unique identifier of the current active preferred IPv6 interface.
        /// </summary>
        /// <value>Unique identifier of the current active preferred IPv6 interface.</value>

        [DataMember(Name="current_preferred_IPv6_interface_id")]
        public string CurrentPreferredIPv6InterfaceId { get; set; }

        /// <summary>
        /// Id of the protection policy applied to the nas server. Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Id of the protection policy applied to the nas server. Was added in version 3.0.0.0.</value>

        [DataMember(Name="protection_policy_id")]
        public string ProtectionPolicyId { get; set; }

        /// <summary>
        ///  Was added in version 3.0.0.0.
        /// </summary>
        /// <value> Was added in version 3.0.0.0.</value>

        [DataMember(Name="file_events_publishing_mode")]
        public FileEventsPublishingModeEnum? FileEventsPublishingMode { get; set; }

        /// <summary>
        /// Indicates whether this NAS Server is a replication destination. A replication destination will be created by the system when a replication session is created. After the replication session is deleted, the replication destination will remain as it is until the end user changes it to be a non-replication destination. After the change, it becomes a production NAS server. If the end user keeps it as a replication destination, when the replication session is recreated, the replication destination NAS server could potentially be reused in the new session.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Indicates whether this NAS Server is a replication destination. A replication destination will be created by the system when a replication session is created. After the replication session is deleted, the replication destination will remain as it is until the end user changes it to be a non-replication destination. After the change, it becomes a production NAS server. If the end user keeps it as a replication destination, when the replication session is recreated, the replication destination NAS server could potentially be reused in the new session.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="is_replication_destination")]
        public bool? IsReplicationDestination { get; set; }

        /// <summary>
        /// true (Production mode) - In this mode, the NAS Server is fully operational. A NAS Server that is not part of a replication is always in production mode. Its configuration can also be changed without any restrictions. A NAS Server that is not part of a replication is always in production mode.  false (Destination mode) - In this mode, user data access and configuration change is restricted. User file systems are all unmounted and so not directly accessible. The administrator may create a snapshot of a file system and share the snap. The data is then only accessible through NFS (not secure nfs) or NDMP. Only network settings of objects can be changed (overridden locally). This includes objects such as network interfaces, dns, nis, ldap etc... This allows a destination NAS Server to have appropriate local network services configured in the event of a failover.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>true (Production mode) - In this mode, the NAS Server is fully operational. A NAS Server that is not part of a replication is always in production mode. Its configuration can also be changed without any restrictions. A NAS Server that is not part of a replication is always in production mode.  false (Destination mode) - In this mode, user data access and configuration change is restricted. User file systems are all unmounted and so not directly accessible. The administrator may create a snapshot of a file system and share the snap. The data is then only accessible through NFS (not secure nfs) or NDMP. Only network settings of objects can be changed (overridden locally). This includes objects such as network interfaces, dns, nis, ldap etc... This allows a destination NAS Server to have appropriate local network services configured in the event of a failover.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="is_production_mode_enabled")]
        public bool? IsProductionModeEnabled { get; set; }

        /// <summary>
        /// Cloning a replicated NAS server destination with the Disaster Recovery Testing option enabled allows for an independent copy of the NAS server to be instantiated so that full DR testing can be done against the clone. The DR test clone will not interfere with the production NAS server, nor will it interfere with the cloned destination should an actual failover occur while the DR test clone is active.  This relies on the clone having a completely isolated network from both the source and destination NAS servers of the replication. The DR test clone will have the same IP addresses as the cloned destination NAS server, so they cannot coexist on the same network. This means that port assignment to the clone must use ports that are not routable to the ports of the replicated destination NAS server.  Was added in version 3.6.0.0.
        /// </summary>
        /// <value>Cloning a replicated NAS server destination with the Disaster Recovery Testing option enabled allows for an independent copy of the NAS server to be instantiated so that full DR testing can be done against the clone. The DR test clone will not interfere with the production NAS server, nor will it interfere with the cloned destination should an actual failover occur while the DR test clone is active.  This relies on the clone having a completely isolated network from both the source and destination NAS servers of the replication. The DR test clone will have the same IP addresses as the cloned destination NAS server, so they cannot coexist on the same network. This means that port assignment to the clone must use ports that are not routable to the ports of the replicated destination NAS server.  Was added in version 3.6.0.0.</value>

        [DataMember(Name="is_dr_test")]
        public bool? IsDrTest { get; set; }

        /// <summary>
        /// Localized message string corresponding to operational_status
        /// </summary>
        /// <value>Localized message string corresponding to operational_status</value>

        [DataMember(Name="operational_status_l10n")]
        public string OperationalStatusL10n { get; set; }

        /// <summary>
        /// Localized message string corresponding to current_unix_directory_service
        /// </summary>
        /// <value>Localized message string corresponding to current_unix_directory_service</value>

        [DataMember(Name="current_unix_directory_service_l10n")]
        public string CurrentUnixDirectoryServiceL10n { get; set; }

        /// <summary>
        /// Localized message string corresponding to file_events_publishing_mode Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Localized message string corresponding to file_events_publishing_mode Was added in version 3.0.0.0.</value>

        [DataMember(Name="file_events_publishing_mode_l10n")]
        public string FileEventsPublishingModeL10n { get; set; }

        /// <summary>
        /// This is the embeddable reference form of protection_policy_id attribute.
        /// </summary>
        /// <value>This is the embeddable reference form of protection_policy_id attribute.</value>

        [DataMember(Name="protection_policy")]
        public PolicyInstance ProtectionPolicy { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_interface association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_interface association.</value>

        [DataMember(Name="file_interfaces")]
        public List<FileInterfaceInstance> FileInterfaces { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_ndmp association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_ndmp association.</value>

        [DataMember(Name="file_ndmps")]
        public List<FileNdmpInstance> FileNdmps { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_virus_checker association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_virus_checker association.</value>

        [DataMember(Name="file_virus_checkers")]
        public List<FileVirusCheckerInstance> FileVirusCheckers { get; set; }

        /// <summary>
        /// This is the inverse of the resource type nfs_server association.
        /// </summary>
        /// <value>This is the inverse of the resource type nfs_server association.</value>

        [DataMember(Name="nfs_servers")]
        public List<NfsServerInstance> NfsServers { get; set; }

        /// <summary>
        /// This is the inverse of the resource type smb_server association.
        /// </summary>
        /// <value>This is the inverse of the resource type smb_server association.</value>

        [DataMember(Name="smb_servers")]
        public List<SmbServerInstance> SmbServers { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_dns association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_dns association.</value>

        [DataMember(Name="file_dnses")]
        public List<FileDnsInstance> FileDnses { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_ftp association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_ftp association.</value>

        [DataMember(Name="file_ftps")]
        public List<FileFtpInstance> FileFtps { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_kerberos association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_kerberos association.</value>

        [DataMember(Name="file_kerberoses")]
        public List<FileKerberosInstance> FileKerberoses { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_ldap association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_ldap association.</value>

        [DataMember(Name="file_ldaps")]
        public List<FileLdapInstance> FileLdaps { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_nis association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_nis association.</value>

        [DataMember(Name="file_nises")]
        public List<FileNisInstance> FileNises { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_system association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_system association.</value>

        [DataMember(Name="file_systems")]
        public List<FileSystemInstance> FileSystems { get; set; }

        /// <summary>
        /// This is the inverse of the resource type file_dhsm_config association.
        /// </summary>
        /// <value>This is the inverse of the resource type file_dhsm_config association.</value>

        [DataMember(Name="file_dhsm_configs")]
        public List<FileDhsmConfigInstance> FileDhsmConfigs { get; set; }

        /// <summary>
        /// List of the file_events_publishers that are associated with this nas_server.
        /// </summary>
        /// <value>List of the file_events_publishers that are associated with this nas_server.</value>

        [DataMember(Name="file_events_publishers")]
        public List<FileEventsPublisherInstance> FileEventsPublishers { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NasServerInstance {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  OperationalStatus: ").Append(OperationalStatus).Append("\n");
            sb.Append("  CurrentNodeId: ").Append(CurrentNodeId).Append("\n");
            sb.Append("  PreferredNodeId: ").Append(PreferredNodeId).Append("\n");
            sb.Append("  DefaultUnixUser: ").Append(DefaultUnixUser).Append("\n");
            sb.Append("  DefaultWindowsUser: ").Append(DefaultWindowsUser).Append("\n");
            sb.Append("  CurrentUnixDirectoryService: ").Append(CurrentUnixDirectoryService).Append("\n");
            sb.Append("  IsUsernameTranslationEnabled: ").Append(IsUsernameTranslationEnabled).Append("\n");
            sb.Append("  IsAutoUserMappingEnabled: ").Append(IsAutoUserMappingEnabled).Append("\n");
            sb.Append("  ProductionIPv4InterfaceId: ").Append(ProductionIPv4InterfaceId).Append("\n");
            sb.Append("  ProductionIPv6InterfaceId: ").Append(ProductionIPv6InterfaceId).Append("\n");
            sb.Append("  BackupIPv4InterfaceId: ").Append(BackupIPv4InterfaceId).Append("\n");
            sb.Append("  BackupIPv6InterfaceId: ").Append(BackupIPv6InterfaceId).Append("\n");
            sb.Append("  CurrentPreferredIPv4InterfaceId: ").Append(CurrentPreferredIPv4InterfaceId).Append("\n");
            sb.Append("  CurrentPreferredIPv6InterfaceId: ").Append(CurrentPreferredIPv6InterfaceId).Append("\n");
            sb.Append("  ProtectionPolicyId: ").Append(ProtectionPolicyId).Append("\n");
            sb.Append("  FileEventsPublishingMode: ").Append(FileEventsPublishingMode).Append("\n");
            sb.Append("  IsReplicationDestination: ").Append(IsReplicationDestination).Append("\n");
            sb.Append("  IsProductionModeEnabled: ").Append(IsProductionModeEnabled).Append("\n");
            sb.Append("  IsDrTest: ").Append(IsDrTest).Append("\n");
            sb.Append("  OperationalStatusL10n: ").Append(OperationalStatusL10n).Append("\n");
            sb.Append("  CurrentUnixDirectoryServiceL10n: ").Append(CurrentUnixDirectoryServiceL10n).Append("\n");
            sb.Append("  FileEventsPublishingModeL10n: ").Append(FileEventsPublishingModeL10n).Append("\n");
            sb.Append("  ProtectionPolicy: ").Append(ProtectionPolicy).Append("\n");
            sb.Append("  FileInterfaces: ").Append(FileInterfaces).Append("\n");
            sb.Append("  FileNdmps: ").Append(FileNdmps).Append("\n");
            sb.Append("  FileVirusCheckers: ").Append(FileVirusCheckers).Append("\n");
            sb.Append("  NfsServers: ").Append(NfsServers).Append("\n");
            sb.Append("  SmbServers: ").Append(SmbServers).Append("\n");
            sb.Append("  FileDnses: ").Append(FileDnses).Append("\n");
            sb.Append("  FileFtps: ").Append(FileFtps).Append("\n");
            sb.Append("  FileKerberoses: ").Append(FileKerberoses).Append("\n");
            sb.Append("  FileLdaps: ").Append(FileLdaps).Append("\n");
            sb.Append("  FileNises: ").Append(FileNises).Append("\n");
            sb.Append("  FileSystems: ").Append(FileSystems).Append("\n");
            sb.Append("  FileDhsmConfigs: ").Append(FileDhsmConfigs).Append("\n");
            sb.Append("  FileEventsPublishers: ").Append(FileEventsPublishers).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((NasServerInstance)obj);
        }

        /// <summary>
        /// Returns true if NasServerInstance instances are equal
        /// </summary>
        /// <param name="other">Instance of NasServerInstance to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NasServerInstance other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Id == other.Id ||
                    Id != null &&
                    Id.Equals(other.Id)
                ) && 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    Description == other.Description ||
                    Description != null &&
                    Description.Equals(other.Description)
                ) && 
                (
                    OperationalStatus == other.OperationalStatus ||
                    OperationalStatus != null &&
                    OperationalStatus.Equals(other.OperationalStatus)
                ) && 
                (
                    CurrentNodeId == other.CurrentNodeId ||
                    CurrentNodeId != null &&
                    CurrentNodeId.Equals(other.CurrentNodeId)
                ) && 
                (
                    PreferredNodeId == other.PreferredNodeId ||
                    PreferredNodeId != null &&
                    PreferredNodeId.Equals(other.PreferredNodeId)
                ) && 
                (
                    DefaultUnixUser == other.DefaultUnixUser ||
                    DefaultUnixUser != null &&
                    DefaultUnixUser.Equals(other.DefaultUnixUser)
                ) && 
                (
                    DefaultWindowsUser == other.DefaultWindowsUser ||
                    DefaultWindowsUser != null &&
                    DefaultWindowsUser.Equals(other.DefaultWindowsUser)
                ) && 
                (
                    CurrentUnixDirectoryService == other.CurrentUnixDirectoryService ||
                    CurrentUnixDirectoryService != null &&
                    CurrentUnixDirectoryService.Equals(other.CurrentUnixDirectoryService)
                ) && 
                (
                    IsUsernameTranslationEnabled == other.IsUsernameTranslationEnabled ||
                    IsUsernameTranslationEnabled != null &&
                    IsUsernameTranslationEnabled.Equals(other.IsUsernameTranslationEnabled)
                ) && 
                (
                    IsAutoUserMappingEnabled == other.IsAutoUserMappingEnabled ||
                    IsAutoUserMappingEnabled != null &&
                    IsAutoUserMappingEnabled.Equals(other.IsAutoUserMappingEnabled)
                ) && 
                (
                    ProductionIPv4InterfaceId == other.ProductionIPv4InterfaceId ||
                    ProductionIPv4InterfaceId != null &&
                    ProductionIPv4InterfaceId.Equals(other.ProductionIPv4InterfaceId)
                ) && 
                (
                    ProductionIPv6InterfaceId == other.ProductionIPv6InterfaceId ||
                    ProductionIPv6InterfaceId != null &&
                    ProductionIPv6InterfaceId.Equals(other.ProductionIPv6InterfaceId)
                ) && 
                (
                    BackupIPv4InterfaceId == other.BackupIPv4InterfaceId ||
                    BackupIPv4InterfaceId != null &&
                    BackupIPv4InterfaceId.Equals(other.BackupIPv4InterfaceId)
                ) && 
                (
                    BackupIPv6InterfaceId == other.BackupIPv6InterfaceId ||
                    BackupIPv6InterfaceId != null &&
                    BackupIPv6InterfaceId.Equals(other.BackupIPv6InterfaceId)
                ) && 
                (
                    CurrentPreferredIPv4InterfaceId == other.CurrentPreferredIPv4InterfaceId ||
                    CurrentPreferredIPv4InterfaceId != null &&
                    CurrentPreferredIPv4InterfaceId.Equals(other.CurrentPreferredIPv4InterfaceId)
                ) && 
                (
                    CurrentPreferredIPv6InterfaceId == other.CurrentPreferredIPv6InterfaceId ||
                    CurrentPreferredIPv6InterfaceId != null &&
                    CurrentPreferredIPv6InterfaceId.Equals(other.CurrentPreferredIPv6InterfaceId)
                ) && 
                (
                    ProtectionPolicyId == other.ProtectionPolicyId ||
                    ProtectionPolicyId != null &&
                    ProtectionPolicyId.Equals(other.ProtectionPolicyId)
                ) && 
                (
                    FileEventsPublishingMode == other.FileEventsPublishingMode ||
                    FileEventsPublishingMode != null &&
                    FileEventsPublishingMode.Equals(other.FileEventsPublishingMode)
                ) && 
                (
                    IsReplicationDestination == other.IsReplicationDestination ||
                    IsReplicationDestination != null &&
                    IsReplicationDestination.Equals(other.IsReplicationDestination)
                ) && 
                (
                    IsProductionModeEnabled == other.IsProductionModeEnabled ||
                    IsProductionModeEnabled != null &&
                    IsProductionModeEnabled.Equals(other.IsProductionModeEnabled)
                ) && 
                (
                    IsDrTest == other.IsDrTest ||
                    IsDrTest != null &&
                    IsDrTest.Equals(other.IsDrTest)
                ) && 
                (
                    OperationalStatusL10n == other.OperationalStatusL10n ||
                    OperationalStatusL10n != null &&
                    OperationalStatusL10n.Equals(other.OperationalStatusL10n)
                ) && 
                (
                    CurrentUnixDirectoryServiceL10n == other.CurrentUnixDirectoryServiceL10n ||
                    CurrentUnixDirectoryServiceL10n != null &&
                    CurrentUnixDirectoryServiceL10n.Equals(other.CurrentUnixDirectoryServiceL10n)
                ) && 
                (
                    FileEventsPublishingModeL10n == other.FileEventsPublishingModeL10n ||
                    FileEventsPublishingModeL10n != null &&
                    FileEventsPublishingModeL10n.Equals(other.FileEventsPublishingModeL10n)
                ) && 
                (
                    ProtectionPolicy == other.ProtectionPolicy ||
                    ProtectionPolicy != null &&
                    ProtectionPolicy.Equals(other.ProtectionPolicy)
                ) && 
                (
                    FileInterfaces == other.FileInterfaces ||
                    FileInterfaces != null &&
                    FileInterfaces.SequenceEqual(other.FileInterfaces)
                ) && 
                (
                    FileNdmps == other.FileNdmps ||
                    FileNdmps != null &&
                    FileNdmps.SequenceEqual(other.FileNdmps)
                ) && 
                (
                    FileVirusCheckers == other.FileVirusCheckers ||
                    FileVirusCheckers != null &&
                    FileVirusCheckers.SequenceEqual(other.FileVirusCheckers)
                ) && 
                (
                    NfsServers == other.NfsServers ||
                    NfsServers != null &&
                    NfsServers.SequenceEqual(other.NfsServers)
                ) && 
                (
                    SmbServers == other.SmbServers ||
                    SmbServers != null &&
                    SmbServers.SequenceEqual(other.SmbServers)
                ) && 
                (
                    FileDnses == other.FileDnses ||
                    FileDnses != null &&
                    FileDnses.SequenceEqual(other.FileDnses)
                ) && 
                (
                    FileFtps == other.FileFtps ||
                    FileFtps != null &&
                    FileFtps.SequenceEqual(other.FileFtps)
                ) && 
                (
                    FileKerberoses == other.FileKerberoses ||
                    FileKerberoses != null &&
                    FileKerberoses.SequenceEqual(other.FileKerberoses)
                ) && 
                (
                    FileLdaps == other.FileLdaps ||
                    FileLdaps != null &&
                    FileLdaps.SequenceEqual(other.FileLdaps)
                ) && 
                (
                    FileNises == other.FileNises ||
                    FileNises != null &&
                    FileNises.SequenceEqual(other.FileNises)
                ) && 
                (
                    FileSystems == other.FileSystems ||
                    FileSystems != null &&
                    FileSystems.SequenceEqual(other.FileSystems)
                ) && 
                (
                    FileDhsmConfigs == other.FileDhsmConfigs ||
                    FileDhsmConfigs != null &&
                    FileDhsmConfigs.SequenceEqual(other.FileDhsmConfigs)
                ) && 
                (
                    FileEventsPublishers == other.FileEventsPublishers ||
                    FileEventsPublishers != null &&
                    FileEventsPublishers.SequenceEqual(other.FileEventsPublishers)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Id != null)
                    hashCode = hashCode * 59 + Id.GetHashCode();
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (Description != null)
                    hashCode = hashCode * 59 + Description.GetHashCode();
                    if (OperationalStatus != null)
                    hashCode = hashCode * 59 + OperationalStatus.GetHashCode();
                    if (CurrentNodeId != null)
                    hashCode = hashCode * 59 + CurrentNodeId.GetHashCode();
                    if (PreferredNodeId != null)
                    hashCode = hashCode * 59 + PreferredNodeId.GetHashCode();
                    if (DefaultUnixUser != null)
                    hashCode = hashCode * 59 + DefaultUnixUser.GetHashCode();
                    if (DefaultWindowsUser != null)
                    hashCode = hashCode * 59 + DefaultWindowsUser.GetHashCode();
                    if (CurrentUnixDirectoryService != null)
                    hashCode = hashCode * 59 + CurrentUnixDirectoryService.GetHashCode();
                    if (IsUsernameTranslationEnabled != null)
                    hashCode = hashCode * 59 + IsUsernameTranslationEnabled.GetHashCode();
                    if (IsAutoUserMappingEnabled != null)
                    hashCode = hashCode * 59 + IsAutoUserMappingEnabled.GetHashCode();
                    if (ProductionIPv4InterfaceId != null)
                    hashCode = hashCode * 59 + ProductionIPv4InterfaceId.GetHashCode();
                    if (ProductionIPv6InterfaceId != null)
                    hashCode = hashCode * 59 + ProductionIPv6InterfaceId.GetHashCode();
                    if (BackupIPv4InterfaceId != null)
                    hashCode = hashCode * 59 + BackupIPv4InterfaceId.GetHashCode();
                    if (BackupIPv6InterfaceId != null)
                    hashCode = hashCode * 59 + BackupIPv6InterfaceId.GetHashCode();
                    if (CurrentPreferredIPv4InterfaceId != null)
                    hashCode = hashCode * 59 + CurrentPreferredIPv4InterfaceId.GetHashCode();
                    if (CurrentPreferredIPv6InterfaceId != null)
                    hashCode = hashCode * 59 + CurrentPreferredIPv6InterfaceId.GetHashCode();
                    if (ProtectionPolicyId != null)
                    hashCode = hashCode * 59 + ProtectionPolicyId.GetHashCode();
                    if (FileEventsPublishingMode != null)
                    hashCode = hashCode * 59 + FileEventsPublishingMode.GetHashCode();
                    if (IsReplicationDestination != null)
                    hashCode = hashCode * 59 + IsReplicationDestination.GetHashCode();
                    if (IsProductionModeEnabled != null)
                    hashCode = hashCode * 59 + IsProductionModeEnabled.GetHashCode();
                    if (IsDrTest != null)
                    hashCode = hashCode * 59 + IsDrTest.GetHashCode();
                    if (OperationalStatusL10n != null)
                    hashCode = hashCode * 59 + OperationalStatusL10n.GetHashCode();
                    if (CurrentUnixDirectoryServiceL10n != null)
                    hashCode = hashCode * 59 + CurrentUnixDirectoryServiceL10n.GetHashCode();
                    if (FileEventsPublishingModeL10n != null)
                    hashCode = hashCode * 59 + FileEventsPublishingModeL10n.GetHashCode();
                    if (ProtectionPolicy != null)
                    hashCode = hashCode * 59 + ProtectionPolicy.GetHashCode();
                    if (FileInterfaces != null)
                    hashCode = hashCode * 59 + FileInterfaces.GetHashCode();
                    if (FileNdmps != null)
                    hashCode = hashCode * 59 + FileNdmps.GetHashCode();
                    if (FileVirusCheckers != null)
                    hashCode = hashCode * 59 + FileVirusCheckers.GetHashCode();
                    if (NfsServers != null)
                    hashCode = hashCode * 59 + NfsServers.GetHashCode();
                    if (SmbServers != null)
                    hashCode = hashCode * 59 + SmbServers.GetHashCode();
                    if (FileDnses != null)
                    hashCode = hashCode * 59 + FileDnses.GetHashCode();
                    if (FileFtps != null)
                    hashCode = hashCode * 59 + FileFtps.GetHashCode();
                    if (FileKerberoses != null)
                    hashCode = hashCode * 59 + FileKerberoses.GetHashCode();
                    if (FileLdaps != null)
                    hashCode = hashCode * 59 + FileLdaps.GetHashCode();
                    if (FileNises != null)
                    hashCode = hashCode * 59 + FileNises.GetHashCode();
                    if (FileSystems != null)
                    hashCode = hashCode * 59 + FileSystems.GetHashCode();
                    if (FileDhsmConfigs != null)
                    hashCode = hashCode * 59 + FileDhsmConfigs.GetHashCode();
                    if (FileEventsPublishers != null)
                    hashCode = hashCode * 59 + FileEventsPublishers.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(NasServerInstance left, NasServerInstance right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(NasServerInstance left, NasServerInstance right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
