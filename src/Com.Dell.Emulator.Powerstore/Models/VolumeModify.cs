/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Com.Dell.Emulator.Powerstore.Models
{ 
    /// <summary>
    /// Parameters for the volume modify operation.
    /// </summary>
    [DataContract]
    public partial class VolumeModify : IEquatable<VolumeModify>
    { 
        /// <summary>
        /// New name of the volume. This value must contain 128 or fewer printable Unicode characters. 
        /// </summary>
        /// <value>New name of the volume. This value must contain 128 or fewer printable Unicode characters. </value>

        [StringLength(128, MinimumLength=1)]
        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// New description of the volume. This value must contain 128 or fewer printable Unicode characters. 
        /// </summary>
        /// <value>New description of the volume. This value must contain 128 or fewer printable Unicode characters. </value>

        [MaxLength(128)]
        [DataMember(Name="description")]
        public string Description { get; set; }

        /// <summary>
        /// New size of the volume in bytes, must be a multiple of 8192, must be bigger than the current volume size. Maximum volume size is 256TB. 
        /// </summary>
        /// <value>New size of the volume in bytes, must be a multiple of 8192, must be bigger than the current volume size. Maximum volume size is 256TB. </value>

        [Range(1048576, 281474976710656)]
        [DataMember(Name="size")]
        public long? Size { get; set; }

        /// <summary>
        /// New expiration time of the snapshot. Expired snapshots are deleted by the snapshot aging service that runs periodically in the background. If not specified, the snapshot never expires.  Use a maximum timestamp value or null to set an expiration to never expire. 
        /// </summary>
        /// <value>New expiration time of the snapshot. Expired snapshots are deleted by the snapshot aging service that runs periodically in the background. If not specified, the snapshot never expires.  Use a maximum timestamp value or null to set an expiration to never expire. </value>

        [DataMember(Name="expiration_timestamp")]
        public DateTime? ExpirationTimestamp { get; set; }

        /// <summary>
        /// Unique identifier of the protection policy assigned to the volume. name:{name} can be used instead of {id}. For example: &#39;protection_policy_id&#39;:&#39;name:policy_name&#39;
        /// </summary>
        /// <value>Unique identifier of the protection policy assigned to the volume. name:{name} can be used instead of {id}. For example: &#39;protection_policy_id&#39;:&#39;name:policy_name&#39;</value>

        [DataMember(Name="protection_policy_id")]
        public string ProtectionPolicyId { get; set; }

        /// <summary>
        /// Unique identifier of the performance policy assigned to the volume. name:{name} can be used instead of {id}. For example: &#39;performance_policy_id&#39;:&#39;name:policy_name&#39;
        /// </summary>
        /// <value>Unique identifier of the performance policy assigned to the volume. name:{name} can be used instead of {id}. For example: &#39;performance_policy_id&#39;:&#39;name:policy_name&#39;</value>

        [DataMember(Name="performance_policy_id")]
        public string PerformancePolicyId { get; set; }

        /// <summary>
        /// Unique identifier of the QoS performance policy assigned to the volume. If an empty string or null is specified, the QoS performance policy will be removed from this volume.  name:{name} can be used instead of {id}. For example: &#39;qos_performance_policy_id&#39;:&#39;name:policy_name&#39; Was added in version 4.0.0.0.
        /// </summary>
        /// <value>Unique identifier of the QoS performance policy assigned to the volume. If an empty string or null is specified, the QoS performance policy will be removed from this volume.  name:{name} can be used instead of {id}. For example: &#39;qos_performance_policy_id&#39;:&#39;name:policy_name&#39; Was added in version 4.0.0.0.</value>

        [DataMember(Name="qos_performance_policy_id")]
        public string QosPerformancePolicyId { get; set; }

        /// <summary>
        /// New value for is_replication_destination property. The modification is only supported for primary and clone volume, only when the current value is true and there is no longer a replication session using this volume as a destination, and only to false. 
        /// </summary>
        /// <value>New value for is_replication_destination property. The modification is only supported for primary and clone volume, only when the current value is true and there is no longer a replication session using this volume as a destination, and only to false. </value>

        [DataMember(Name="is_replication_destination")]
        public bool? IsReplicationDestination { get; set; }

        /// <summary>
        /// Normally a replication destination volume cannot be modified since it is controlled by replication. However, there can be cases where replication has failed or is no longer active and the replication destination volume needs to be cleaned up.  With the force option, the user will be allowed to remove the protection policy from the replication destination volume provided that the replication session has never been synchronized and the last_sync_timestamp property is empty.  This parameter defaults to false, if not specified. 
        /// </summary>
        /// <value>Normally a replication destination volume cannot be modified since it is controlled by replication. However, there can be cases where replication has failed or is no longer active and the replication destination volume needs to be cleaned up.  With the force option, the user will be allowed to remove the protection policy from the replication destination volume provided that the replication session has never been synchronized and the last_sync_timestamp property is empty.  This parameter defaults to false, if not specified. </value>

        [DataMember(Name="force")]
        public bool? Force { get; set; }

        /// <summary>
        /// Set which node will optimized for IO.
        /// </summary>
        /// <value>Set which node will optimized for IO.</value>

        [DataMember(Name="node_affinity")]
        public NodeAffinityEnum? NodeAffinity { get; set; }

        /// <summary>
        ///  Was added in version 2.1.0.0.
        /// </summary>
        /// <value> Was added in version 2.1.0.0.</value>

        [DataMember(Name="app_type")]
        public AppTypeEnum? AppType { get; set; }

        /// <summary>
        /// An optional field used to describe application type usage for a volume. This field can only be set if app_type is set to Relational_Databases_Other, Big_Data_Analytics_Other, Business_Applications_Other, Healthcare_Other, Virtualization_Other or Other. If the app_type attribute is set to anything other than one of these values, the attribute will be cleared.  Was added in version 2.1.0.0.
        /// </summary>
        /// <value>An optional field used to describe application type usage for a volume. This field can only be set if app_type is set to Relational_Databases_Other, Big_Data_Analytics_Other, Business_Applications_Other, Healthcare_Other, Virtualization_Other or Other. If the app_type attribute is set to anything other than one of these values, the attribute will be cleared.  Was added in version 2.1.0.0.</value>

        [MaxLength(32)]
        [DataMember(Name="app_type_other")]
        public string AppTypeOther { get; set; }

        /// <summary>
        /// This parameter only applies to block snapshots. If true, mark the snapshot as a secured snapshot. An expiration timestamp must also be set or be specified. A secure snapshot can not be unlocked by setting this flag to false.  Was added in version 3.5.0.0.
        /// </summary>
        /// <value>This parameter only applies to block snapshots. If true, mark the snapshot as a secured snapshot. An expiration timestamp must also be set or be specified. A secure snapshot can not be unlocked by setting this flag to false.  Was added in version 3.5.0.0.</value>

        [DataMember(Name="is_secure")]
        public bool? IsSecure { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class VolumeModify {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Size: ").Append(Size).Append("\n");
            sb.Append("  ExpirationTimestamp: ").Append(ExpirationTimestamp).Append("\n");
            sb.Append("  ProtectionPolicyId: ").Append(ProtectionPolicyId).Append("\n");
            sb.Append("  PerformancePolicyId: ").Append(PerformancePolicyId).Append("\n");
            sb.Append("  QosPerformancePolicyId: ").Append(QosPerformancePolicyId).Append("\n");
            sb.Append("  IsReplicationDestination: ").Append(IsReplicationDestination).Append("\n");
            sb.Append("  Force: ").Append(Force).Append("\n");
            sb.Append("  NodeAffinity: ").Append(NodeAffinity).Append("\n");
            sb.Append("  AppType: ").Append(AppType).Append("\n");
            sb.Append("  AppTypeOther: ").Append(AppTypeOther).Append("\n");
            sb.Append("  IsSecure: ").Append(IsSecure).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((VolumeModify)obj);
        }

        /// <summary>
        /// Returns true if VolumeModify instances are equal
        /// </summary>
        /// <param name="other">Instance of VolumeModify to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(VolumeModify other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    Description == other.Description ||
                    Description != null &&
                    Description.Equals(other.Description)
                ) && 
                (
                    Size == other.Size ||
                    Size != null &&
                    Size.Equals(other.Size)
                ) && 
                (
                    ExpirationTimestamp == other.ExpirationTimestamp ||
                    ExpirationTimestamp != null &&
                    ExpirationTimestamp.Equals(other.ExpirationTimestamp)
                ) && 
                (
                    ProtectionPolicyId == other.ProtectionPolicyId ||
                    ProtectionPolicyId != null &&
                    ProtectionPolicyId.Equals(other.ProtectionPolicyId)
                ) && 
                (
                    PerformancePolicyId == other.PerformancePolicyId ||
                    PerformancePolicyId != null &&
                    PerformancePolicyId.Equals(other.PerformancePolicyId)
                ) && 
                (
                    QosPerformancePolicyId == other.QosPerformancePolicyId ||
                    QosPerformancePolicyId != null &&
                    QosPerformancePolicyId.Equals(other.QosPerformancePolicyId)
                ) && 
                (
                    IsReplicationDestination == other.IsReplicationDestination ||
                    IsReplicationDestination != null &&
                    IsReplicationDestination.Equals(other.IsReplicationDestination)
                ) && 
                (
                    Force == other.Force ||
                    Force != null &&
                    Force.Equals(other.Force)
                ) && 
                (
                    NodeAffinity == other.NodeAffinity ||
                    NodeAffinity != null &&
                    NodeAffinity.Equals(other.NodeAffinity)
                ) && 
                (
                    AppType == other.AppType ||
                    AppType != null &&
                    AppType.Equals(other.AppType)
                ) && 
                (
                    AppTypeOther == other.AppTypeOther ||
                    AppTypeOther != null &&
                    AppTypeOther.Equals(other.AppTypeOther)
                ) && 
                (
                    IsSecure == other.IsSecure ||
                    IsSecure != null &&
                    IsSecure.Equals(other.IsSecure)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (Description != null)
                    hashCode = hashCode * 59 + Description.GetHashCode();
                    if (Size != null)
                    hashCode = hashCode * 59 + Size.GetHashCode();
                    if (ExpirationTimestamp != null)
                    hashCode = hashCode * 59 + ExpirationTimestamp.GetHashCode();
                    if (ProtectionPolicyId != null)
                    hashCode = hashCode * 59 + ProtectionPolicyId.GetHashCode();
                    if (PerformancePolicyId != null)
                    hashCode = hashCode * 59 + PerformancePolicyId.GetHashCode();
                    if (QosPerformancePolicyId != null)
                    hashCode = hashCode * 59 + QosPerformancePolicyId.GetHashCode();
                    if (IsReplicationDestination != null)
                    hashCode = hashCode * 59 + IsReplicationDestination.GetHashCode();
                    if (Force != null)
                    hashCode = hashCode * 59 + Force.GetHashCode();
                    if (NodeAffinity != null)
                    hashCode = hashCode * 59 + NodeAffinity.GetHashCode();
                    if (AppType != null)
                    hashCode = hashCode * 59 + AppType.GetHashCode();
                    if (AppTypeOther != null)
                    hashCode = hashCode * 59 + AppTypeOther.GetHashCode();
                    if (IsSecure != null)
                    hashCode = hashCode * 59 + IsSecure.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(VolumeModify left, VolumeModify right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(VolumeModify left, VolumeModify right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
