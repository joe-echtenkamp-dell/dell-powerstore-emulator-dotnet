/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// Parameters to fail over a replication session. 
    /// </summary>
    [DataContract]
    public partial class ReplicationSessionFailover : IEquatable<ReplicationSessionFailover>
    { 
        /// <summary>
        /// Indicates whether the replication session failover is planned or unplanned. For planned failovers, the value is true. For unplanned failovers, the value is false. 
        /// </summary>
        /// <value>Indicates whether the replication session failover is planned or unplanned. For planned failovers, the value is true. For unplanned failovers, the value is false. </value>

        [DataMember(Name="is_planned")]
        public bool? IsPlanned { get; set; }

        /// <summary>
        /// Indicates whether the system is auto-reprotected. Auto-reprotect is combination of failover and reprotect. This is only allowed when issuing a planned failover. 
        /// </summary>
        /// <value>Indicates whether the system is auto-reprotected. Auto-reprotect is combination of failover and reprotect. This is only allowed when issuing a planned failover. </value>

        [DataMember(Name="reverse")]
        public bool? Reverse { get; set; }

        /// <summary>
        /// When a failover test is in progress and an unplanned failover needs to be started, this flag must be set to true. Setting this flag to true will keep the destination resources&#39; data as is before starting the unplanned failover. Please stop the failover test first if you do not wish to keep the test data before starting an unplanned failover.  Was added in version 2.0.0.0.
        /// </summary>
        /// <value>When a failover test is in progress and an unplanned failover needs to be started, this flag must be set to true. Setting this flag to true will keep the destination resources&#39; data as is before starting the unplanned failover. Please stop the failover test first if you do not wish to keep the test data before starting an unplanned failover.  Was added in version 2.0.0.0.</value>

        [DataMember(Name="use_test_copy")]
        public bool? UseTestCopy { get; set; }

        /// <summary>
        /// Optional identifier of a snapshot that the destination resource must be restored to as part of an unplanned failover. If a failover_snapshot_id is not specified, the destination will be restored to the last common base snapshot. This identifier is not supported when a failover test is in progress.  Was added in version 2.0.0.0.
        /// </summary>
        /// <value>Optional identifier of a snapshot that the destination resource must be restored to as part of an unplanned failover. If a failover_snapshot_id is not specified, the destination will be restored to the last common base snapshot. This identifier is not supported when a failover test is in progress.  Was added in version 2.0.0.0.</value>

        [DataMember(Name="failover_snapshot_id")]
        public string FailoverSnapshotId { get; set; }

        /// <summary>
        /// Indicates whether an unplanned failover needs to be performed for a session that is already in a failed over state. 
        /// </summary>
        /// <value>Indicates whether an unplanned failover needs to be performed for a session that is already in a failed over state. </value>

        [DataMember(Name="force")]
        public bool? Force { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ReplicationSessionFailover {\n");
            sb.Append("  IsPlanned: ").Append(IsPlanned).Append("\n");
            sb.Append("  Reverse: ").Append(Reverse).Append("\n");
            sb.Append("  UseTestCopy: ").Append(UseTestCopy).Append("\n");
            sb.Append("  FailoverSnapshotId: ").Append(FailoverSnapshotId).Append("\n");
            sb.Append("  Force: ").Append(Force).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((ReplicationSessionFailover)obj);
        }

        /// <summary>
        /// Returns true if ReplicationSessionFailover instances are equal
        /// </summary>
        /// <param name="other">Instance of ReplicationSessionFailover to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReplicationSessionFailover other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    IsPlanned == other.IsPlanned ||
                    IsPlanned != null &&
                    IsPlanned.Equals(other.IsPlanned)
                ) && 
                (
                    Reverse == other.Reverse ||
                    Reverse != null &&
                    Reverse.Equals(other.Reverse)
                ) && 
                (
                    UseTestCopy == other.UseTestCopy ||
                    UseTestCopy != null &&
                    UseTestCopy.Equals(other.UseTestCopy)
                ) && 
                (
                    FailoverSnapshotId == other.FailoverSnapshotId ||
                    FailoverSnapshotId != null &&
                    FailoverSnapshotId.Equals(other.FailoverSnapshotId)
                ) && 
                (
                    Force == other.Force ||
                    Force != null &&
                    Force.Equals(other.Force)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (IsPlanned != null)
                    hashCode = hashCode * 59 + IsPlanned.GetHashCode();
                    if (Reverse != null)
                    hashCode = hashCode * 59 + Reverse.GetHashCode();
                    if (UseTestCopy != null)
                    hashCode = hashCode * 59 + UseTestCopy.GetHashCode();
                    if (FailoverSnapshotId != null)
                    hashCode = hashCode * 59 + FailoverSnapshotId.GetHashCode();
                    if (Force != null)
                    hashCode = hashCode * 59 + Force.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(ReplicationSessionFailover left, ReplicationSessionFailover right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(ReplicationSessionFailover left, ReplicationSessionFailover right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
