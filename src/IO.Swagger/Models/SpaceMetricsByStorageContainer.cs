/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// Space metrics of storage container aggregated from all appliances collected at five minute interval.
    /// </summary>
    [DataContract]
    public partial class SpaceMetricsByStorageContainer : MetricsGenerateResponse, IEquatable<SpaceMetricsByStorageContainer>
    { 
        /// <summary>
        /// Internal ID of the storage container.
        /// </summary>
        /// <value>Internal ID of the storage container.</value>

        [DataMember(Name="storage_container_id")]
        public string StorageContainerId { get; set; }

        /// <summary>
        /// End of sample period.
        /// </summary>
        /// <value>End of sample period.</value>

        [DataMember(Name="timestamp")]
        public DateTime? Timestamp { get; set; }

        /// <summary>
        /// Total configured size in bytes of the primary and clone virtual volumes within the storage container.
        /// </summary>
        /// <value>Total configured size in bytes of the primary and clone virtual volumes within the storage container.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="logical_provisioned")]
        public long? LogicalProvisioned { get; set; }

        /// <summary>
        /// Amount of data in bytes written to primary and clone virtual volumes within the storage container.
        /// </summary>
        /// <value>Amount of data in bytes written to primary and clone virtual volumes within the storage container.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="logical_used")]
        public long? LogicalUsed { get; set; }

        /// <summary>
        /// Amount of space the storage container needs to hold the data written by host and shared by snaps and fast-clones in their families; this does not include deduplication or compression. Was added in version 2.0.0.0.
        /// </summary>
        /// <value>Amount of space the storage container needs to hold the data written by host and shared by snaps and fast-clones in their families; this does not include deduplication or compression. Was added in version 2.0.0.0.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="shared_logical_used")]
        public long? SharedLogicalUsed { get; set; }

        /// <summary>
        /// Ratio of the amount of space that would have been used by snapshots if space efficiency was not applied to logical space used solely by snapshots. For example, a volume is provisioned as 1 GB and it has two snapshots. Each snapshot has 200 MB of data. Snapshot savings will be (1 GB + 1 GB) / (0.2 GB + 0.2 GB) or 5:1. The snapshot_savings value will be 5 in this case.
        /// </summary>
        /// <value>Ratio of the amount of space that would have been used by snapshots if space efficiency was not applied to logical space used solely by snapshots. For example, a volume is provisioned as 1 GB and it has two snapshots. Each snapshot has 200 MB of data. Snapshot savings will be (1 GB + 1 GB) / (0.2 GB + 0.2 GB) or 5:1. The snapshot_savings value will be 5 in this case.</value>

        [DataMember(Name="snapshot_savings")]
        public float? SnapshotSavings { get; set; }

        /// <summary>
        /// Amount of physical space storage container used after compression and deduplication. This is the space to be freed up if a storage container is removed. Was added in version 3.5.0.0.
        /// </summary>
        /// <value>Amount of physical space storage container used after compression and deduplication. This is the space to be freed up if a storage container is removed. Was added in version 3.5.0.0.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="unique_physical_used")]
        public long? UniquePhysicalUsed { get; set; }

        /// <summary>
        /// Total amount of data in bytes host has written to all volumes used by storage container without any deduplication, compression or sharing. This metric includes snaps and clones in the volume family used by storage container. Was added in version 3.5.0.0.
        /// </summary>
        /// <value>Total amount of data in bytes host has written to all volumes used by storage container without any deduplication, compression or sharing. This metric includes snaps and clones in the volume family used by storage container. Was added in version 3.5.0.0.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="snap_clone_logical_used")]
        public long? SnapCloneLogicalUsed { get; set; }

        /// <summary>
        /// Ratio of all the vVol provisioned to data they contain. This is the ratio of logical_provisioned to logical_used. For example, a SC has two 2 GB vVol&#39;s and have written 500 MB of data to them. The thin savings would be (2 * 2GB) / (2 * 0.5 GB) or 4:1, so the thin_savings value would be 4.0. Was added in version 3.5.0.0.
        /// </summary>
        /// <value>Ratio of all the vVol provisioned to data they contain. This is the ratio of logical_provisioned to logical_used. For example, a SC has two 2 GB vVol&#39;s and have written 500 MB of data to them. The thin savings would be (2 * 2GB) / (2 * 0.5 GB) or 4:1, so the thin_savings value would be 4.0. Was added in version 3.5.0.0.</value>

        [DataMember(Name="thin_savings")]
        public float? ThinSavings { get; set; }

        /// <summary>
        /// Amount of data that cannot be compressed or deduped. A null value indicates insufficient data to calculate the unreducible data. Was added in version 4.0.0.0.
        /// </summary>
        /// <value>Amount of data that cannot be compressed or deduped. A null value indicates insufficient data to calculate the unreducible data. Was added in version 4.0.0.0.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="unreducible_data")]
        public long? UnreducibleData { get; set; }

        /// <summary>
        /// Ratio of the logical used space to data physical used space which is after deduplication and compression. Was added in version 4.0.0.0.
        /// </summary>
        /// <value>Ratio of the logical used space to data physical used space which is after deduplication and compression. Was added in version 4.0.0.0.</value>

        [DataMember(Name="data_reduction")]
        public float? DataReduction { get; set; }

        /// <summary>
        /// Ratio of the logical used space to data physical used space which is after deduplication and compression, based on reducible data only. Was added in version 4.0.0.0.
        /// </summary>
        /// <value>Ratio of the logical used space to data physical used space which is after deduplication and compression, based on reducible data only. Was added in version 4.0.0.0.</value>

        [DataMember(Name="reducible_data_reduction")]
        public float? ReducibleDataReduction { get; set; }

        /// <summary>
        /// Number of times the metrics are repeated.
        /// </summary>
        /// <value>Number of times the metrics are repeated.</value>

        [Range(0, 2147483647)]
        [DataMember(Name="repeat_count")]
        public int? RepeatCount { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SpaceMetricsByStorageContainer {\n");
            sb.Append("  StorageContainerId: ").Append(StorageContainerId).Append("\n");
            sb.Append("  Timestamp: ").Append(Timestamp).Append("\n");
            sb.Append("  LogicalProvisioned: ").Append(LogicalProvisioned).Append("\n");
            sb.Append("  LogicalUsed: ").Append(LogicalUsed).Append("\n");
            sb.Append("  SharedLogicalUsed: ").Append(SharedLogicalUsed).Append("\n");
            sb.Append("  SnapshotSavings: ").Append(SnapshotSavings).Append("\n");
            sb.Append("  UniquePhysicalUsed: ").Append(UniquePhysicalUsed).Append("\n");
            sb.Append("  SnapCloneLogicalUsed: ").Append(SnapCloneLogicalUsed).Append("\n");
            sb.Append("  ThinSavings: ").Append(ThinSavings).Append("\n");
            sb.Append("  UnreducibleData: ").Append(UnreducibleData).Append("\n");
            sb.Append("  DataReduction: ").Append(DataReduction).Append("\n");
            sb.Append("  ReducibleDataReduction: ").Append(ReducibleDataReduction).Append("\n");
            sb.Append("  RepeatCount: ").Append(RepeatCount).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public  new string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((SpaceMetricsByStorageContainer)obj);
        }

        /// <summary>
        /// Returns true if SpaceMetricsByStorageContainer instances are equal
        /// </summary>
        /// <param name="other">Instance of SpaceMetricsByStorageContainer to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SpaceMetricsByStorageContainer other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    StorageContainerId == other.StorageContainerId ||
                    StorageContainerId != null &&
                    StorageContainerId.Equals(other.StorageContainerId)
                ) && 
                (
                    Timestamp == other.Timestamp ||
                    Timestamp != null &&
                    Timestamp.Equals(other.Timestamp)
                ) && 
                (
                    LogicalProvisioned == other.LogicalProvisioned ||
                    LogicalProvisioned != null &&
                    LogicalProvisioned.Equals(other.LogicalProvisioned)
                ) && 
                (
                    LogicalUsed == other.LogicalUsed ||
                    LogicalUsed != null &&
                    LogicalUsed.Equals(other.LogicalUsed)
                ) && 
                (
                    SharedLogicalUsed == other.SharedLogicalUsed ||
                    SharedLogicalUsed != null &&
                    SharedLogicalUsed.Equals(other.SharedLogicalUsed)
                ) && 
                (
                    SnapshotSavings == other.SnapshotSavings ||
                    SnapshotSavings != null &&
                    SnapshotSavings.Equals(other.SnapshotSavings)
                ) && 
                (
                    UniquePhysicalUsed == other.UniquePhysicalUsed ||
                    UniquePhysicalUsed != null &&
                    UniquePhysicalUsed.Equals(other.UniquePhysicalUsed)
                ) && 
                (
                    SnapCloneLogicalUsed == other.SnapCloneLogicalUsed ||
                    SnapCloneLogicalUsed != null &&
                    SnapCloneLogicalUsed.Equals(other.SnapCloneLogicalUsed)
                ) && 
                (
                    ThinSavings == other.ThinSavings ||
                    ThinSavings != null &&
                    ThinSavings.Equals(other.ThinSavings)
                ) && 
                (
                    UnreducibleData == other.UnreducibleData ||
                    UnreducibleData != null &&
                    UnreducibleData.Equals(other.UnreducibleData)
                ) && 
                (
                    DataReduction == other.DataReduction ||
                    DataReduction != null &&
                    DataReduction.Equals(other.DataReduction)
                ) && 
                (
                    ReducibleDataReduction == other.ReducibleDataReduction ||
                    ReducibleDataReduction != null &&
                    ReducibleDataReduction.Equals(other.ReducibleDataReduction)
                ) && 
                (
                    RepeatCount == other.RepeatCount ||
                    RepeatCount != null &&
                    RepeatCount.Equals(other.RepeatCount)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (StorageContainerId != null)
                    hashCode = hashCode * 59 + StorageContainerId.GetHashCode();
                    if (Timestamp != null)
                    hashCode = hashCode * 59 + Timestamp.GetHashCode();
                    if (LogicalProvisioned != null)
                    hashCode = hashCode * 59 + LogicalProvisioned.GetHashCode();
                    if (LogicalUsed != null)
                    hashCode = hashCode * 59 + LogicalUsed.GetHashCode();
                    if (SharedLogicalUsed != null)
                    hashCode = hashCode * 59 + SharedLogicalUsed.GetHashCode();
                    if (SnapshotSavings != null)
                    hashCode = hashCode * 59 + SnapshotSavings.GetHashCode();
                    if (UniquePhysicalUsed != null)
                    hashCode = hashCode * 59 + UniquePhysicalUsed.GetHashCode();
                    if (SnapCloneLogicalUsed != null)
                    hashCode = hashCode * 59 + SnapCloneLogicalUsed.GetHashCode();
                    if (ThinSavings != null)
                    hashCode = hashCode * 59 + ThinSavings.GetHashCode();
                    if (UnreducibleData != null)
                    hashCode = hashCode * 59 + UnreducibleData.GetHashCode();
                    if (DataReduction != null)
                    hashCode = hashCode * 59 + DataReduction.GetHashCode();
                    if (ReducibleDataReduction != null)
                    hashCode = hashCode * 59 + ReducibleDataReduction.GetHashCode();
                    if (RepeatCount != null)
                    hashCode = hashCode * 59 + RepeatCount.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(SpaceMetricsByStorageContainer left, SpaceMetricsByStorageContainer right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(SpaceMetricsByStorageContainer left, SpaceMetricsByStorageContainer right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
