/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Com.Dell.Emulator.Powerstore.Models
{ 
    /// <summary>
    /// Properties of the network. Values was added in 2.0.0.0: name, purposes. Values was added in 3.0.0.0: nvme_discovery_mode, nvme_cdc_address, nvme_cdc_port. This resource type has queriable association from ip_pool_address
    /// </summary>
    [DataContract]
    public partial class NetworkInstance : IEquatable<NetworkInstance>
    { 
        /// <summary>
        /// Unique identifier of the network.
        /// </summary>
        /// <value>Unique identifier of the network.</value>

        [DataMember(Name="id")]
        public string Id { get; set; }

        /// <summary>
        /// Gets or Sets Type
        /// </summary>

        [DataMember(Name="type")]
        public NetworkTypeEnum? Type { get; set; }

        /// <summary>
        /// Name of the network.  This property supports case-insensitive filtering. Was added in version 2.0.0.0.
        /// </summary>
        /// <value>Name of the network.  This property supports case-insensitive filtering. Was added in version 2.0.0.0.</value>

        [StringLength(128, MinimumLength=1)]
        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// Gets or Sets IpVersion
        /// </summary>

        [DataMember(Name="ip_version")]
        public IpVersionTypeEnum? IpVersion { get; set; }

        /// <summary>
        /// Purposes of the network. This returns a list of purposes for the networks that support multiple purposes per network, like storage network. Empty list is returned for single purposed networks, like management, vMotion, ICD and ICM.  Was added in version 2.0.0.0.
        /// </summary>
        /// <value>Purposes of the network. This returns a list of purposes for the networks that support multiple purposes per network, like storage network. Empty list is returned for single purposed networks, like management, vMotion, ICD and ICM.  Was added in version 2.0.0.0.</value>

        [DataMember(Name="purposes")]
        public List<NetworkPurposeEnum> Purposes { get; set; }

        /// <summary>
        /// VLAN identifier.
        /// </summary>
        /// <value>VLAN identifier.</value>

        [Range(0, 4094)]
        [DataMember(Name="vlan_id")]
        public int? VlanId { get; set; }

        /// <summary>
        /// Network prefix length, used for both IPv4 and IPv6.
        /// </summary>
        /// <value>Network prefix length, used for both IPv4 and IPv6.</value>

        [Range(1, 127)]
        [DataMember(Name="prefix_length")]
        public int? PrefixLength { get; set; }

        /// <summary>
        /// Network gateway in IPv4 or IPv6 format, corresponding to the network&#39;s IP version.
        /// </summary>
        /// <value>Network gateway in IPv4 or IPv6 format, corresponding to the network&#39;s IP version.</value>

        [DataMember(Name="gateway")]
        public string Gateway { get; set; }

        /// <summary>
        /// Maximum Transmission Unit (MTU) packet size set on network interfaces, in bytes.
        /// </summary>
        /// <value>Maximum Transmission Unit (MTU) packet size set on network interfaces, in bytes.</value>

        [Range(1280, 9000)]
        [DataMember(Name="mtu")]
        public int? Mtu { get; set; }

        /// <summary>
        ///  Was added in version 3.0.0.0.
        /// </summary>
        /// <value> Was added in version 3.0.0.0.</value>

        [DataMember(Name="nvme_discovery_mode")]
        public NVMeDiscoveryModeEnum? NvmeDiscoveryMode { get; set; }

        /// <summary>
        /// IP address of the NVMe Centralized Discovery Controller (CDC). This is only applicable if network contains NVMe_TCP among its purposes, and nvme_discovery_mode is set to Manual_CDC.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>IP address of the NVMe Centralized Discovery Controller (CDC). This is only applicable if network contains NVMe_TCP among its purposes, and nvme_discovery_mode is set to Manual_CDC.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="nvme_cdc_address")]
        public string NvmeCdcAddress { get; set; }

        /// <summary>
        /// TCP port of the NVMe Centralized Discovery Controller (CDC). This is only applicable if network contains NVMe_TCP among its purposes, and nvme_discovery_mode is set to Manual_CDC. The valid values: 8009 or from 49152 to 49999 or 50100 to 65535.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>TCP port of the NVMe Centralized Discovery Controller (CDC). This is only applicable if network contains NVMe_TCP among its purposes, and nvme_discovery_mode is set to Manual_CDC. The valid values: 8009 or from 49152 to 49999 or 50100 to 65535.  Was added in version 3.0.0.0.</value>

        [Range(8009, 65535)]
        [DataMember(Name="nvme_cdc_port")]
        public int? NvmeCdcPort { get; set; }

        /// <summary>
        /// Localized message string corresponding to type
        /// </summary>
        /// <value>Localized message string corresponding to type</value>

        [DataMember(Name="type_l10n")]
        public string TypeL10n { get; set; }

        /// <summary>
        /// Localized message string corresponding to ip_version
        /// </summary>
        /// <value>Localized message string corresponding to ip_version</value>

        [DataMember(Name="ip_version_l10n")]
        public string IpVersionL10n { get; set; }

        /// <summary>
        /// Localized message array corresponding to purposes Was added in version 2.0.0.0.
        /// </summary>
        /// <value>Localized message array corresponding to purposes Was added in version 2.0.0.0.</value>

        [DataMember(Name="purposes_l10n")]
        public List<string> PurposesL10n { get; set; }

        /// <summary>
        /// Localized message string corresponding to nvme_discovery_mode Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Localized message string corresponding to nvme_discovery_mode Was added in version 3.0.0.0.</value>

        [DataMember(Name="nvme_discovery_mode_l10n")]
        public string NvmeDiscoveryModeL10n { get; set; }

        /// <summary>
        /// This is the inverse of the resource type ip_pool_address association.
        /// </summary>
        /// <value>This is the inverse of the resource type ip_pool_address association.</value>

        [DataMember(Name="ip_pool_addresses")]
        public List<IpPoolAddressInstance> IpPoolAddresses { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NetworkInstance {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  IpVersion: ").Append(IpVersion).Append("\n");
            sb.Append("  Purposes: ").Append(Purposes).Append("\n");
            sb.Append("  VlanId: ").Append(VlanId).Append("\n");
            sb.Append("  PrefixLength: ").Append(PrefixLength).Append("\n");
            sb.Append("  Gateway: ").Append(Gateway).Append("\n");
            sb.Append("  Mtu: ").Append(Mtu).Append("\n");
            sb.Append("  NvmeDiscoveryMode: ").Append(NvmeDiscoveryMode).Append("\n");
            sb.Append("  NvmeCdcAddress: ").Append(NvmeCdcAddress).Append("\n");
            sb.Append("  NvmeCdcPort: ").Append(NvmeCdcPort).Append("\n");
            sb.Append("  TypeL10n: ").Append(TypeL10n).Append("\n");
            sb.Append("  IpVersionL10n: ").Append(IpVersionL10n).Append("\n");
            sb.Append("  PurposesL10n: ").Append(PurposesL10n).Append("\n");
            sb.Append("  NvmeDiscoveryModeL10n: ").Append(NvmeDiscoveryModeL10n).Append("\n");
            sb.Append("  IpPoolAddresses: ").Append(IpPoolAddresses).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((NetworkInstance)obj);
        }

        /// <summary>
        /// Returns true if NetworkInstance instances are equal
        /// </summary>
        /// <param name="other">Instance of NetworkInstance to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NetworkInstance other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Id == other.Id ||
                    Id != null &&
                    Id.Equals(other.Id)
                ) && 
                (
                    Type == other.Type ||
                    Type != null &&
                    Type.Equals(other.Type)
                ) && 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    IpVersion == other.IpVersion ||
                    IpVersion != null &&
                    IpVersion.Equals(other.IpVersion)
                ) && 
                (
                    Purposes == other.Purposes ||
                    Purposes != null &&
                    Purposes.SequenceEqual(other.Purposes)
                ) && 
                (
                    VlanId == other.VlanId ||
                    VlanId != null &&
                    VlanId.Equals(other.VlanId)
                ) && 
                (
                    PrefixLength == other.PrefixLength ||
                    PrefixLength != null &&
                    PrefixLength.Equals(other.PrefixLength)
                ) && 
                (
                    Gateway == other.Gateway ||
                    Gateway != null &&
                    Gateway.Equals(other.Gateway)
                ) && 
                (
                    Mtu == other.Mtu ||
                    Mtu != null &&
                    Mtu.Equals(other.Mtu)
                ) && 
                (
                    NvmeDiscoveryMode == other.NvmeDiscoveryMode ||
                    NvmeDiscoveryMode != null &&
                    NvmeDiscoveryMode.Equals(other.NvmeDiscoveryMode)
                ) && 
                (
                    NvmeCdcAddress == other.NvmeCdcAddress ||
                    NvmeCdcAddress != null &&
                    NvmeCdcAddress.Equals(other.NvmeCdcAddress)
                ) && 
                (
                    NvmeCdcPort == other.NvmeCdcPort ||
                    NvmeCdcPort != null &&
                    NvmeCdcPort.Equals(other.NvmeCdcPort)
                ) && 
                (
                    TypeL10n == other.TypeL10n ||
                    TypeL10n != null &&
                    TypeL10n.Equals(other.TypeL10n)
                ) && 
                (
                    IpVersionL10n == other.IpVersionL10n ||
                    IpVersionL10n != null &&
                    IpVersionL10n.Equals(other.IpVersionL10n)
                ) && 
                (
                    PurposesL10n == other.PurposesL10n ||
                    PurposesL10n != null &&
                    PurposesL10n.SequenceEqual(other.PurposesL10n)
                ) && 
                (
                    NvmeDiscoveryModeL10n == other.NvmeDiscoveryModeL10n ||
                    NvmeDiscoveryModeL10n != null &&
                    NvmeDiscoveryModeL10n.Equals(other.NvmeDiscoveryModeL10n)
                ) && 
                (
                    IpPoolAddresses == other.IpPoolAddresses ||
                    IpPoolAddresses != null &&
                    IpPoolAddresses.SequenceEqual(other.IpPoolAddresses)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Id != null)
                    hashCode = hashCode * 59 + Id.GetHashCode();
                    if (Type != null)
                    hashCode = hashCode * 59 + Type.GetHashCode();
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (IpVersion != null)
                    hashCode = hashCode * 59 + IpVersion.GetHashCode();
                    if (Purposes != null)
                    hashCode = hashCode * 59 + Purposes.GetHashCode();
                    if (VlanId != null)
                    hashCode = hashCode * 59 + VlanId.GetHashCode();
                    if (PrefixLength != null)
                    hashCode = hashCode * 59 + PrefixLength.GetHashCode();
                    if (Gateway != null)
                    hashCode = hashCode * 59 + Gateway.GetHashCode();
                    if (Mtu != null)
                    hashCode = hashCode * 59 + Mtu.GetHashCode();
                    if (NvmeDiscoveryMode != null)
                    hashCode = hashCode * 59 + NvmeDiscoveryMode.GetHashCode();
                    if (NvmeCdcAddress != null)
                    hashCode = hashCode * 59 + NvmeCdcAddress.GetHashCode();
                    if (NvmeCdcPort != null)
                    hashCode = hashCode * 59 + NvmeCdcPort.GetHashCode();
                    if (TypeL10n != null)
                    hashCode = hashCode * 59 + TypeL10n.GetHashCode();
                    if (IpVersionL10n != null)
                    hashCode = hashCode * 59 + IpVersionL10n.GetHashCode();
                    if (PurposesL10n != null)
                    hashCode = hashCode * 59 + PurposesL10n.GetHashCode();
                    if (NvmeDiscoveryModeL10n != null)
                    hashCode = hashCode * 59 + NvmeDiscoveryModeL10n.GetHashCode();
                    if (IpPoolAddresses != null)
                    hashCode = hashCode * 59 + IpPoolAddresses.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(NetworkInstance left, NetworkInstance right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(NetworkInstance left, NetworkInstance right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
