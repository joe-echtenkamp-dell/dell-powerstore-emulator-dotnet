/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// Arguments for the modify operation.
    /// </summary>
    [DataContract]
    public partial class NasServerModify : IEquatable<NasServerModify>
    { 
        /// <summary>
        /// Name of the NAS server.
        /// </summary>
        /// <value>Name of the NAS server.</value>

        [StringLength(255, MinimumLength=1)]
        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// Description of the NAS server.
        /// </summary>
        /// <value>Description of the NAS server.</value>

        [StringLength(255, MinimumLength=0)]
        [DataMember(Name="description")]
        public string Description { get; set; }

        /// <summary>
        /// Unique identifier of the node on which the NAS server is running.
        /// </summary>
        /// <value>Unique identifier of the node on which the NAS server is running.</value>

        [DataMember(Name="current_node_id")]
        public string CurrentNodeId { get; set; }

        /// <summary>
        /// Unique identifier of the preferred node for the NAS server The initial value (on NAS server create) is taken from the current node.
        /// </summary>
        /// <value>Unique identifier of the preferred node for the NAS server The initial value (on NAS server create) is taken from the current node.</value>

        [DataMember(Name="preferred_node_id")]
        public string PreferredNodeId { get; set; }

        /// <summary>
        /// Gets or Sets CurrentUnixDirectoryService
        /// </summary>

        [DataMember(Name="current_unix_directory_service")]
        public NASServerCurrentUnixDirectoryServiceEnum? CurrentUnixDirectoryService { get; set; }

        /// <summary>
        /// Default Unix user name used for granting access in case of Windows to Unix user mapping failure. When empty, access in such case is denied.
        /// </summary>
        /// <value>Default Unix user name used for granting access in case of Windows to Unix user mapping failure. When empty, access in such case is denied.</value>

        [StringLength(63, MinimumLength=0)]
        [DataMember(Name="default_unix_user")]
        public string DefaultUnixUser { get; set; }

        /// <summary>
        /// Default Windows user name used for granting access in case of Unix to Windows user mapping failure. When empty, access in such case is denied.
        /// </summary>
        /// <value>Default Windows user name used for granting access in case of Unix to Windows user mapping failure. When empty, access in such case is denied.</value>

        [StringLength(1023, MinimumLength=0)]
        [DataMember(Name="default_windows_user")]
        public string DefaultWindowsUser { get; set; }

        /// <summary>
        /// Enable the possibility to match a windows account to a Unix account with different names
        /// </summary>
        /// <value>Enable the possibility to match a windows account to a Unix account with different names</value>

        [DataMember(Name="is_username_translation_enabled")]
        public bool? IsUsernameTranslationEnabled { get; set; }

        /// <summary>
        /// A Windows user must have a corresponding matching Unix user (uid) in order to connect. This attribute enables you to automatically generate this Unix user (uid), if that Windows user does not have any in the configured Unix directory service (UDS). In a pure SMB or non multi-protocol environment, this should be set to true. 
        /// </summary>
        /// <value>A Windows user must have a corresponding matching Unix user (uid) in order to connect. This attribute enables you to automatically generate this Unix user (uid), if that Windows user does not have any in the configured Unix directory service (UDS). In a pure SMB or non multi-protocol environment, this should be set to true. </value>

        [DataMember(Name="is_auto_user_mapping_enabled")]
        public bool? IsAutoUserMappingEnabled { get; set; }

        /// <summary>
        /// Unique identifier of the preferred IPv4 production interface.
        /// </summary>
        /// <value>Unique identifier of the preferred IPv4 production interface.</value>

        [DataMember(Name="production_IPv4_interface_id")]
        public string ProductionIPv4InterfaceId { get; set; }

        /// <summary>
        /// Unique identifier of the preferred IPv6 production interface.
        /// </summary>
        /// <value>Unique identifier of the preferred IPv6 production interface.</value>

        [DataMember(Name="production_IPv6_interface_id")]
        public string ProductionIPv6InterfaceId { get; set; }

        /// <summary>
        /// Unique identifier of the preferred IPv4 backup interface.
        /// </summary>
        /// <value>Unique identifier of the preferred IPv4 backup interface.</value>

        [DataMember(Name="backup_IPv4_interface_id")]
        public string BackupIPv4InterfaceId { get; set; }

        /// <summary>
        /// Unique identifier of the preferred IPv6 backup interface.
        /// </summary>
        /// <value>Unique identifier of the preferred IPv6 backup interface.</value>

        [DataMember(Name="backup_IPv6_interface_id")]
        public string BackupIPv6InterfaceId { get; set; }

        /// <summary>
        /// Unique identifier of the file events publisher. name:{name} can be used instead of {id}. For example: &#39;file_events_publisher_id&#39;:&#39;name:file_events_publisher_name&#39; Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Unique identifier of the file events publisher. name:{name} can be used instead of {id}. For example: &#39;file_events_publisher_id&#39;:&#39;name:file_events_publisher_name&#39; Was added in version 3.0.0.0.</value>

        [DataMember(Name="file_events_publisher_id")]
        public string FileEventsPublisherId { get; set; }

        /// <summary>
        ///  Was added in version 3.0.0.0.
        /// </summary>
        /// <value> Was added in version 3.0.0.0.</value>

        [DataMember(Name="file_events_publishing_mode")]
        public FileEventsPublishingModeEnum? FileEventsPublishingMode { get; set; }

        /// <summary>
        /// Id of the protection policy applied to the nas server. name:{name} can be used instead of {id}. For example: &#39;protection_policy_id&#39;:&#39;name:policy_name&#39; Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Id of the protection policy applied to the nas server. name:{name} can be used instead of {id}. For example: &#39;protection_policy_id&#39;:&#39;name:policy_name&#39; Was added in version 3.0.0.0.</value>

        [DataMember(Name="protection_policy_id")]
        public string ProtectionPolicyId { get; set; }

        /// <summary>
        /// New value for is_replication_destination property. The modification is supported only when the current value is true and there is no longer a replication session using this NAS Server as a destination, and only to false.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>New value for is_replication_destination property. The modification is supported only when the current value is true and there is no longer a replication session using this NAS Server as a destination, and only to false.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="is_replication_destination")]
        public bool? IsReplicationDestination { get; set; }

        /// <summary>
        /// true (Production mode) - In this mode, the NAS Server is fully operational. User data is accessible through regular protocols like SMB/NFS etc. Its configuration can also be changed without any restrictions. A NAS Server that is not part of a replication is always in production mode.  false (Destination mode) - In this mode, user data access and configuration change is restricted. User file systems are all unmounted and so not directly accessible. The administrator may create a snapshot of a file system and share the snap. The data is then only accessible through NFS (not secure nfs) or NDMP. Only network settings of objects can be changed (overridden locally). This includes objects such as network interfaces, dns, nis, ldap etc... This allows a destination NAS Server to have appropriate local network services configured in the event of a failover.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>true (Production mode) - In this mode, the NAS Server is fully operational. User data is accessible through regular protocols like SMB/NFS etc. Its configuration can also be changed without any restrictions. A NAS Server that is not part of a replication is always in production mode.  false (Destination mode) - In this mode, user data access and configuration change is restricted. User file systems are all unmounted and so not directly accessible. The administrator may create a snapshot of a file system and share the snap. The data is then only accessible through NFS (not secure nfs) or NDMP. Only network settings of objects can be changed (overridden locally). This includes objects such as network interfaces, dns, nis, ldap etc... This allows a destination NAS Server to have appropriate local network services configured in the event of a failover.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="is_production_mode_enabled")]
        public bool? IsProductionModeEnabled { get; set; }

        /// <summary>
        /// Normally a replication destination NAS server cannot be modified since it is controlled by replication. However, there can be cases where replication has failed or is no longer active and the replication destination NAS server needs to be cleaned up.  With the force option, the user will be allowed to remove the protection policy from the replication destination NAS server provided that the replication session does not exists.  This parameter defaults to false, if not specified.  Was added in version 3.0.0.0.
        /// </summary>
        /// <value>Normally a replication destination NAS server cannot be modified since it is controlled by replication. However, there can be cases where replication has failed or is no longer active and the replication destination NAS server needs to be cleaned up.  With the force option, the user will be allowed to remove the protection policy from the replication destination NAS server provided that the replication session does not exists.  This parameter defaults to false, if not specified.  Was added in version 3.0.0.0.</value>

        [DataMember(Name="force")]
        public bool? Force { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NasServerModify {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  CurrentNodeId: ").Append(CurrentNodeId).Append("\n");
            sb.Append("  PreferredNodeId: ").Append(PreferredNodeId).Append("\n");
            sb.Append("  CurrentUnixDirectoryService: ").Append(CurrentUnixDirectoryService).Append("\n");
            sb.Append("  DefaultUnixUser: ").Append(DefaultUnixUser).Append("\n");
            sb.Append("  DefaultWindowsUser: ").Append(DefaultWindowsUser).Append("\n");
            sb.Append("  IsUsernameTranslationEnabled: ").Append(IsUsernameTranslationEnabled).Append("\n");
            sb.Append("  IsAutoUserMappingEnabled: ").Append(IsAutoUserMappingEnabled).Append("\n");
            sb.Append("  ProductionIPv4InterfaceId: ").Append(ProductionIPv4InterfaceId).Append("\n");
            sb.Append("  ProductionIPv6InterfaceId: ").Append(ProductionIPv6InterfaceId).Append("\n");
            sb.Append("  BackupIPv4InterfaceId: ").Append(BackupIPv4InterfaceId).Append("\n");
            sb.Append("  BackupIPv6InterfaceId: ").Append(BackupIPv6InterfaceId).Append("\n");
            sb.Append("  FileEventsPublisherId: ").Append(FileEventsPublisherId).Append("\n");
            sb.Append("  FileEventsPublishingMode: ").Append(FileEventsPublishingMode).Append("\n");
            sb.Append("  ProtectionPolicyId: ").Append(ProtectionPolicyId).Append("\n");
            sb.Append("  IsReplicationDestination: ").Append(IsReplicationDestination).Append("\n");
            sb.Append("  IsProductionModeEnabled: ").Append(IsProductionModeEnabled).Append("\n");
            sb.Append("  Force: ").Append(Force).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((NasServerModify)obj);
        }

        /// <summary>
        /// Returns true if NasServerModify instances are equal
        /// </summary>
        /// <param name="other">Instance of NasServerModify to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NasServerModify other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    Description == other.Description ||
                    Description != null &&
                    Description.Equals(other.Description)
                ) && 
                (
                    CurrentNodeId == other.CurrentNodeId ||
                    CurrentNodeId != null &&
                    CurrentNodeId.Equals(other.CurrentNodeId)
                ) && 
                (
                    PreferredNodeId == other.PreferredNodeId ||
                    PreferredNodeId != null &&
                    PreferredNodeId.Equals(other.PreferredNodeId)
                ) && 
                (
                    CurrentUnixDirectoryService == other.CurrentUnixDirectoryService ||
                    CurrentUnixDirectoryService != null &&
                    CurrentUnixDirectoryService.Equals(other.CurrentUnixDirectoryService)
                ) && 
                (
                    DefaultUnixUser == other.DefaultUnixUser ||
                    DefaultUnixUser != null &&
                    DefaultUnixUser.Equals(other.DefaultUnixUser)
                ) && 
                (
                    DefaultWindowsUser == other.DefaultWindowsUser ||
                    DefaultWindowsUser != null &&
                    DefaultWindowsUser.Equals(other.DefaultWindowsUser)
                ) && 
                (
                    IsUsernameTranslationEnabled == other.IsUsernameTranslationEnabled ||
                    IsUsernameTranslationEnabled != null &&
                    IsUsernameTranslationEnabled.Equals(other.IsUsernameTranslationEnabled)
                ) && 
                (
                    IsAutoUserMappingEnabled == other.IsAutoUserMappingEnabled ||
                    IsAutoUserMappingEnabled != null &&
                    IsAutoUserMappingEnabled.Equals(other.IsAutoUserMappingEnabled)
                ) && 
                (
                    ProductionIPv4InterfaceId == other.ProductionIPv4InterfaceId ||
                    ProductionIPv4InterfaceId != null &&
                    ProductionIPv4InterfaceId.Equals(other.ProductionIPv4InterfaceId)
                ) && 
                (
                    ProductionIPv6InterfaceId == other.ProductionIPv6InterfaceId ||
                    ProductionIPv6InterfaceId != null &&
                    ProductionIPv6InterfaceId.Equals(other.ProductionIPv6InterfaceId)
                ) && 
                (
                    BackupIPv4InterfaceId == other.BackupIPv4InterfaceId ||
                    BackupIPv4InterfaceId != null &&
                    BackupIPv4InterfaceId.Equals(other.BackupIPv4InterfaceId)
                ) && 
                (
                    BackupIPv6InterfaceId == other.BackupIPv6InterfaceId ||
                    BackupIPv6InterfaceId != null &&
                    BackupIPv6InterfaceId.Equals(other.BackupIPv6InterfaceId)
                ) && 
                (
                    FileEventsPublisherId == other.FileEventsPublisherId ||
                    FileEventsPublisherId != null &&
                    FileEventsPublisherId.Equals(other.FileEventsPublisherId)
                ) && 
                (
                    FileEventsPublishingMode == other.FileEventsPublishingMode ||
                    FileEventsPublishingMode != null &&
                    FileEventsPublishingMode.Equals(other.FileEventsPublishingMode)
                ) && 
                (
                    ProtectionPolicyId == other.ProtectionPolicyId ||
                    ProtectionPolicyId != null &&
                    ProtectionPolicyId.Equals(other.ProtectionPolicyId)
                ) && 
                (
                    IsReplicationDestination == other.IsReplicationDestination ||
                    IsReplicationDestination != null &&
                    IsReplicationDestination.Equals(other.IsReplicationDestination)
                ) && 
                (
                    IsProductionModeEnabled == other.IsProductionModeEnabled ||
                    IsProductionModeEnabled != null &&
                    IsProductionModeEnabled.Equals(other.IsProductionModeEnabled)
                ) && 
                (
                    Force == other.Force ||
                    Force != null &&
                    Force.Equals(other.Force)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (Description != null)
                    hashCode = hashCode * 59 + Description.GetHashCode();
                    if (CurrentNodeId != null)
                    hashCode = hashCode * 59 + CurrentNodeId.GetHashCode();
                    if (PreferredNodeId != null)
                    hashCode = hashCode * 59 + PreferredNodeId.GetHashCode();
                    if (CurrentUnixDirectoryService != null)
                    hashCode = hashCode * 59 + CurrentUnixDirectoryService.GetHashCode();
                    if (DefaultUnixUser != null)
                    hashCode = hashCode * 59 + DefaultUnixUser.GetHashCode();
                    if (DefaultWindowsUser != null)
                    hashCode = hashCode * 59 + DefaultWindowsUser.GetHashCode();
                    if (IsUsernameTranslationEnabled != null)
                    hashCode = hashCode * 59 + IsUsernameTranslationEnabled.GetHashCode();
                    if (IsAutoUserMappingEnabled != null)
                    hashCode = hashCode * 59 + IsAutoUserMappingEnabled.GetHashCode();
                    if (ProductionIPv4InterfaceId != null)
                    hashCode = hashCode * 59 + ProductionIPv4InterfaceId.GetHashCode();
                    if (ProductionIPv6InterfaceId != null)
                    hashCode = hashCode * 59 + ProductionIPv6InterfaceId.GetHashCode();
                    if (BackupIPv4InterfaceId != null)
                    hashCode = hashCode * 59 + BackupIPv4InterfaceId.GetHashCode();
                    if (BackupIPv6InterfaceId != null)
                    hashCode = hashCode * 59 + BackupIPv6InterfaceId.GetHashCode();
                    if (FileEventsPublisherId != null)
                    hashCode = hashCode * 59 + FileEventsPublisherId.GetHashCode();
                    if (FileEventsPublishingMode != null)
                    hashCode = hashCode * 59 + FileEventsPublishingMode.GetHashCode();
                    if (ProtectionPolicyId != null)
                    hashCode = hashCode * 59 + ProtectionPolicyId.GetHashCode();
                    if (IsReplicationDestination != null)
                    hashCode = hashCode * 59 + IsReplicationDestination.GetHashCode();
                    if (IsProductionModeEnabled != null)
                    hashCode = hashCode * 59 + IsProductionModeEnabled.GetHashCode();
                    if (Force != null)
                    hashCode = hashCode * 59 + Force.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(NasServerModify left, NasServerModify right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(NasServerModify left, NasServerModify right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
