/*
 * PowerStore REST API
 *
 * Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )
 *
 * OpenAPI spec version: 4.0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Com.Dell.Emulator.Powerstore.Models
{ 
    /// <summary>
    /// Space metrics for a volume group collected at a five minute interval.
    /// </summary>
    [DataContract]
    public partial class BaseSpaceMetricsByVg : IEquatable<BaseSpaceMetricsByVg>
    { 
        /// <summary>
        /// Unique identifier representing a volume group.
        /// </summary>
        /// <value>Unique identifier representing a volume group.</value>

        [DataMember(Name="vg_id")]
        public string VgId { get; set; }

        /// <summary>
        /// End of sample period.
        /// </summary>
        /// <value>End of sample period.</value>

        [DataMember(Name="timestamp")]
        public DateTime? Timestamp { get; set; }

        /// <summary>
        /// Total configured size in bytes of all member volumes in a volume group.
        /// </summary>
        /// <value>Total configured size in bytes of all member volumes in a volume group.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="logical_provisioned")]
        public long? LogicalProvisioned { get; set; }

        /// <summary>
        /// Total amount of data in bytes written to all member volumes in a volume group.
        /// </summary>
        /// <value>Total amount of data in bytes written to all member volumes in a volume group.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="logical_used")]
        public long? LogicalUsed { get; set; }

        /// <summary>
        /// Total amount of data in bytes host has written to all volumes in the volume group without any deduplication, compression or sharing. This metric includes used snaps and clones in the volume group.
        /// </summary>
        /// <value>Total amount of data in bytes host has written to all volumes in the volume group without any deduplication, compression or sharing. This metric includes used snaps and clones in the volume group.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="snap_clone_logical_used")]
        public long? SnapCloneLogicalUsed { get; set; }

        /// <summary>
        /// Ratio of all the volumes provisioned to data being written to them. For example, a volume group has two 2 GB volumes and have written 500 MB of data to them. The thin savings would be (2 * 2 GB) / (2 * 0.5 GB) or 4:1, so the thin_savings value would be 4.0.
        /// </summary>
        /// <value>Ratio of all the volumes provisioned to data being written to them. For example, a volume group has two 2 GB volumes and have written 500 MB of data to them. The thin savings would be (2 * 2 GB) / (2 * 0.5 GB) or 4:1, so the thin_savings value would be 4.0.</value>

        [DataMember(Name="thin_savings")]
        public float? ThinSavings { get; set; }

        /// <summary>
        /// Ratio of the amount of space that would have been used by snapshots in the volume group if space efficiency was not applied to logical space used solely by snapshots. For example, two volumes are provisioned as 1 GB and each has two snapshots. Each snapshot has 200 MB of data. Snapshot savings will be (1 GB * 2 + 1 GB * 2) / (0.2 GB * 2 + 0.2 GB * 2) or 5:1. The snapshot_savings value will be 5 in this case.
        /// </summary>
        /// <value>Ratio of the amount of space that would have been used by snapshots in the volume group if space efficiency was not applied to logical space used solely by snapshots. For example, two volumes are provisioned as 1 GB and each has two snapshots. Each snapshot has 200 MB of data. Snapshot savings will be (1 GB * 2 + 1 GB * 2) / (0.2 GB * 2 + 0.2 GB * 2) or 5:1. The snapshot_savings value will be 5 in this case.</value>

        [DataMember(Name="snapshot_savings")]
        public float? SnapshotSavings { get; set; }

        /// <summary>
        /// Amount of space the volume group needs to hold the data written by host and shared by snaps and fast-clones in their families. This does not include deduplication or compression. Was added in version 3.5.0.0.
        /// </summary>
        /// <value>Amount of space the volume group needs to hold the data written by host and shared by snaps and fast-clones in their families. This does not include deduplication or compression. Was added in version 3.5.0.0.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="shared_logical_used")]
        public long? SharedLogicalUsed { get; set; }

        /// <summary>
        /// Amount of physical space volume group used after compression and deduplication. This is the space to be freed up if a volume group is removed. Was added in version 3.5.0.0.
        /// </summary>
        /// <value>Amount of physical space volume group used after compression and deduplication. This is the space to be freed up if a volume group is removed. Was added in version 3.5.0.0.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="unique_physical_used")]
        public long? UniquePhysicalUsed { get; set; }

        /// <summary>
        /// Amount of data that cannot be compressed or deduped. A null value indicates insufficient data to calculate the unreducible data. Was added in version 4.0.0.0.
        /// </summary>
        /// <value>Amount of data that cannot be compressed or deduped. A null value indicates insufficient data to calculate the unreducible data. Was added in version 4.0.0.0.</value>

        [Range(0, -9223372036854775616)]
        [DataMember(Name="unreducible_data")]
        public long? UnreducibleData { get; set; }

        /// <summary>
        /// Ratio of the logical used space to data physical used space which is after deduplication and compression. Was added in version 4.0.0.0.
        /// </summary>
        /// <value>Ratio of the logical used space to data physical used space which is after deduplication and compression. Was added in version 4.0.0.0.</value>

        [DataMember(Name="data_reduction")]
        public float? DataReduction { get; set; }

        /// <summary>
        /// Ratio of the logical used space to data physical used space which is after deduplication and compression, based on reducible data only. Was added in version 4.0.0.0.
        /// </summary>
        /// <value>Ratio of the logical used space to data physical used space which is after deduplication and compression, based on reducible data only. Was added in version 4.0.0.0.</value>

        [DataMember(Name="reducible_data_reduction")]
        public float? ReducibleDataReduction { get; set; }

        /// <summary>
        /// Number of times the metrics are repeated.
        /// </summary>
        /// <value>Number of times the metrics are repeated.</value>

        [Range(0, 2147483647)]
        [DataMember(Name="repeat_count")]
        public int? RepeatCount { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class BaseSpaceMetricsByVg {\n");
            sb.Append("  VgId: ").Append(VgId).Append("\n");
            sb.Append("  Timestamp: ").Append(Timestamp).Append("\n");
            sb.Append("  LogicalProvisioned: ").Append(LogicalProvisioned).Append("\n");
            sb.Append("  LogicalUsed: ").Append(LogicalUsed).Append("\n");
            sb.Append("  SnapCloneLogicalUsed: ").Append(SnapCloneLogicalUsed).Append("\n");
            sb.Append("  ThinSavings: ").Append(ThinSavings).Append("\n");
            sb.Append("  SnapshotSavings: ").Append(SnapshotSavings).Append("\n");
            sb.Append("  SharedLogicalUsed: ").Append(SharedLogicalUsed).Append("\n");
            sb.Append("  UniquePhysicalUsed: ").Append(UniquePhysicalUsed).Append("\n");
            sb.Append("  UnreducibleData: ").Append(UnreducibleData).Append("\n");
            sb.Append("  DataReduction: ").Append(DataReduction).Append("\n");
            sb.Append("  ReducibleDataReduction: ").Append(ReducibleDataReduction).Append("\n");
            sb.Append("  RepeatCount: ").Append(RepeatCount).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((BaseSpaceMetricsByVg)obj);
        }

        /// <summary>
        /// Returns true if BaseSpaceMetricsByVg instances are equal
        /// </summary>
        /// <param name="other">Instance of BaseSpaceMetricsByVg to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(BaseSpaceMetricsByVg other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    VgId == other.VgId ||
                    VgId != null &&
                    VgId.Equals(other.VgId)
                ) && 
                (
                    Timestamp == other.Timestamp ||
                    Timestamp != null &&
                    Timestamp.Equals(other.Timestamp)
                ) && 
                (
                    LogicalProvisioned == other.LogicalProvisioned ||
                    LogicalProvisioned != null &&
                    LogicalProvisioned.Equals(other.LogicalProvisioned)
                ) && 
                (
                    LogicalUsed == other.LogicalUsed ||
                    LogicalUsed != null &&
                    LogicalUsed.Equals(other.LogicalUsed)
                ) && 
                (
                    SnapCloneLogicalUsed == other.SnapCloneLogicalUsed ||
                    SnapCloneLogicalUsed != null &&
                    SnapCloneLogicalUsed.Equals(other.SnapCloneLogicalUsed)
                ) && 
                (
                    ThinSavings == other.ThinSavings ||
                    ThinSavings != null &&
                    ThinSavings.Equals(other.ThinSavings)
                ) && 
                (
                    SnapshotSavings == other.SnapshotSavings ||
                    SnapshotSavings != null &&
                    SnapshotSavings.Equals(other.SnapshotSavings)
                ) && 
                (
                    SharedLogicalUsed == other.SharedLogicalUsed ||
                    SharedLogicalUsed != null &&
                    SharedLogicalUsed.Equals(other.SharedLogicalUsed)
                ) && 
                (
                    UniquePhysicalUsed == other.UniquePhysicalUsed ||
                    UniquePhysicalUsed != null &&
                    UniquePhysicalUsed.Equals(other.UniquePhysicalUsed)
                ) && 
                (
                    UnreducibleData == other.UnreducibleData ||
                    UnreducibleData != null &&
                    UnreducibleData.Equals(other.UnreducibleData)
                ) && 
                (
                    DataReduction == other.DataReduction ||
                    DataReduction != null &&
                    DataReduction.Equals(other.DataReduction)
                ) && 
                (
                    ReducibleDataReduction == other.ReducibleDataReduction ||
                    ReducibleDataReduction != null &&
                    ReducibleDataReduction.Equals(other.ReducibleDataReduction)
                ) && 
                (
                    RepeatCount == other.RepeatCount ||
                    RepeatCount != null &&
                    RepeatCount.Equals(other.RepeatCount)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (VgId != null)
                    hashCode = hashCode * 59 + VgId.GetHashCode();
                    if (Timestamp != null)
                    hashCode = hashCode * 59 + Timestamp.GetHashCode();
                    if (LogicalProvisioned != null)
                    hashCode = hashCode * 59 + LogicalProvisioned.GetHashCode();
                    if (LogicalUsed != null)
                    hashCode = hashCode * 59 + LogicalUsed.GetHashCode();
                    if (SnapCloneLogicalUsed != null)
                    hashCode = hashCode * 59 + SnapCloneLogicalUsed.GetHashCode();
                    if (ThinSavings != null)
                    hashCode = hashCode * 59 + ThinSavings.GetHashCode();
                    if (SnapshotSavings != null)
                    hashCode = hashCode * 59 + SnapshotSavings.GetHashCode();
                    if (SharedLogicalUsed != null)
                    hashCode = hashCode * 59 + SharedLogicalUsed.GetHashCode();
                    if (UniquePhysicalUsed != null)
                    hashCode = hashCode * 59 + UniquePhysicalUsed.GetHashCode();
                    if (UnreducibleData != null)
                    hashCode = hashCode * 59 + UnreducibleData.GetHashCode();
                    if (DataReduction != null)
                    hashCode = hashCode * 59 + DataReduction.GetHashCode();
                    if (ReducibleDataReduction != null)
                    hashCode = hashCode * 59 + ReducibleDataReduction.GetHashCode();
                    if (RepeatCount != null)
                    hashCode = hashCode * 59 + RepeatCount.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(BaseSpaceMetricsByVg left, BaseSpaceMetricsByVg right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(BaseSpaceMetricsByVg left, BaseSpaceMetricsByVg right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
